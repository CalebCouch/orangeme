{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/src/crypto.ts", "../../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/src/utils.ts", "../src/utils.ts"],
  "sourcesContent": ["// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!isBytes(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!isBytes(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    if (!isBytes(a)) throw new Error('Uint8Array expected');\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import type { Jwk } from './jose/jwk.js';\n\nimport { crypto } from '@noble/hashes/crypto';\nimport { randomBytes as nobleRandomBytes } from '@noble/hashes/utils';\n\n/**\n * Checks whether the properties object provided contains the specified property.\n *\n * @example\n * ```ts\n * const obj = { a: 'Bob', t: 30 };\n * checkRequiredProperty({ property: 'a', inObject: obj }); // No error\n * checkRequiredProperty({ property: 'z', inObject: obj }); // Throws TypeError\n * ```\n *\n * @param params - The parameters for the check.\n * @param params.property - Property key to check for.\n * @param params.properties - Properties object to check within.\n * @returns void\n * @throws {TypeError} If the property is not a key in the properties object.\n */\nexport function checkRequiredProperty(params: {\n  property: string,\n  inObject: object\n}): void {\n  if (!params || params.property === undefined || params.inObject === undefined) {\n    throw new TypeError(`One or more required parameters missing: 'property, properties'`);\n  }\n  const { property, inObject } = params;\n  if (!(property in inObject)) {\n    throw new TypeError(`Required parameter missing: '${property}'`);\n  }\n}\n\n/**\n * Checks whether the property specified is a member of the list of valid properties.\n *\n * @example\n * ```ts\n * const property = 'color';\n * const allowedProperties = ['size', 'shape', 'color'];\n * checkValidProperty({ property, allowedProperties }); // No error\n * checkValidProperty({ property: 'weight', allowedProperties }); // Throws TypeError\n * ```\n *\n * @param property Property key to check for.\n * @param allowedProperties Properties Array, Map, or Set to check within.\n * @returns void\n * @throws {TypeError} If the property is not a member of the allowedProperties Array, Map, or Set.\n */\nexport function checkValidProperty(params: {\n  property: string, allowedProperties: ReadonlyArray<string> | Array<string> | Map<string, unknown> | Set<string>\n}): void {\n  if (!params || params.property === undefined || params.allowedProperties === undefined) {\n    throw new TypeError(`One or more required parameters missing: 'property, allowedProperties'`);\n  }\n  const { property, allowedProperties } = params;\n  if (\n    (Array.isArray(allowedProperties) && !allowedProperties.includes(property)) ||\n    (allowedProperties instanceof Set && !allowedProperties.has(property)) ||\n    (allowedProperties instanceof Map && !allowedProperties.has(property))\n  ) {\n    const validProperties = Array.from((allowedProperties instanceof Map) ? allowedProperties.keys() : allowedProperties).join(', ');\n    throw new TypeError(`Out of range: '${property}'. Must be one of '${validProperties}'`);\n  }\n}\n\n/**\n * Determines the JOSE algorithm identifier of the digital signature algorithm based on the `alg` or\n * `crv` property of a {@link Jwk | JWK}.\n *\n * If the `alg` property is present, its value takes precedence and is returned. Otherwise, the\n * `crv` property is used to determine the algorithm.\n *\n * @see {@link https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms | JOSE Algorithms}\n * @see {@link https://datatracker.ietf.org/doc/draft-ietf-jose-fully-specified-algorithms/ | Fully-Specified Algorithms for JOSE and COSE}\n *\n * @example\n * ```ts\n * const publicKey: Jwk = {\n *   \"kty\": \"OKP\",\n *   \"crv\": \"Ed25519\",\n *   \"x\": \"FEJG7OakZi500EydXxuE8uMc8uaAzEJkmQeG8khXANw\"\n * }\n * const algorithm = getJoseSignatureAlgorithmFromPublicKey(publicKey);\n * console.log(algorithm); // Output: \"EdDSA\"\n * ```\n *\n * @param publicKey - A JWK containing the `alg` and/or `crv` properties.\n * @returns The name of the algorithm associated with the key.\n * @throws Error if the algorithm cannot be determined from the provided input.\n */\nexport function getJoseSignatureAlgorithmFromPublicKey(publicKey: Jwk): string {\n  const curveToJoseAlgorithm: Record<string, string> = {\n    'Ed25519'   : 'EdDSA',\n    'P-256'     : 'ES256',\n    'P-384'     : 'ES384',\n    'P-521'     : 'ES512',\n    'secp256k1' : 'ES256K',\n  };\n\n  // If the key contains an `alg` property that matches a JOSE registered algorithm identifier,\n  // return its value.\n  if (publicKey.alg && Object.values(curveToJoseAlgorithm).includes(publicKey.alg)) {\n    return publicKey.alg;\n  }\n\n  // If the key contains a `crv` property, return the corresponding algorithm.\n  if (publicKey.crv && Object.keys(curveToJoseAlgorithm).includes(publicKey.crv)) {\n    return curveToJoseAlgorithm[publicKey.crv];\n  }\n\n  throw new Error(\n    `Unable to determine algorithm based on provided input: alg=${publicKey.alg}, crv=${publicKey.crv}. ` +\n    `Supported 'alg' values: ${Object.values(curveToJoseAlgorithm).join(', ')}. ` +\n    `Supported 'crv' values: ${Object.keys(curveToJoseAlgorithm).join(', ')}.`\n  );\n}\n\n/**\n * Checks if the Web Crypto API is supported in the current runtime environment.\n *\n * @remarks\n * The function uses `globalThis` to provide a universal reference to the global\n * scope, regardless of the environment. `globalThis` is a standard feature introduced\n * in ECMAScript 2020 that is agnostic to the underlying JavaScript environment, making\n * the code portable across browser, Node.js, and Web Workers environments.\n *\n * In a web browser, `globalThis` is equivalent to the `window` object. In Node.js, it\n * is equivalent to the `global` object, and in Web Workers, it corresponds to `self`.\n *\n * This method checks for the `crypto` object and its `subtle` property on the global scope\n * to determine the availability of the Web Crypto API. If both are present, the API is\n * supported; otherwise, it is not.\n *\n * @example\n * ```ts\n * if (isWebCryptoSupported()) {\n *   console.log('Crypto operations can be performed');\n * } else {\n *   console.log('Crypto operations are not supported in this environment');\n * }\n * ```\n *\n * @returns A boolean indicating whether the Web Crypto API is supported in the current environment.\n */\nexport function isWebCryptoSupported(): boolean {\n  if (globalThis.crypto && globalThis.crypto.subtle) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Generates secure pseudorandom values of the specified length using\n * `crypto.getRandomValues`, which defers to the operating system.\n *\n * @remarks\n * This function is a wrapper around `randomBytes` from the '@noble/hashes'\n * package. It's designed to be cryptographically strong, suitable for\n * generating initialization vectors, nonces, and other random values.\n *\n * @see {@link https://www.npmjs.com/package/@noble/hashes | @noble/hashes on NPM} for more\n * information about the underlying implementation.\n *\n * @example\n * ```ts\n * const bytes = randomBytes(32); // Generates 32 random bytes\n * ```\n *\n * @param bytesLength - The number of bytes to generate.\n * @returns A Uint8Array containing the generated random bytes.\n */\nexport function randomBytes(bytesLength: number): Uint8Array {\n  return nobleRandomBytes(bytesLength);\n}\n\n/**\n * Generates a UUID (Universally Unique Identifier) using a\n * cryptographically strong random number generator following\n * the version 4 format, as specified in RFC 4122.\n *\n * A version 4 UUID is a randomly generated UUID. The 13th character\n * is set to '4' to denote version 4, and the 17th character is one\n * of '8', '9', 'A', or 'B' to comply with the variant 1 format of\n * UUIDs (the high bits are set to '10').\n *\n * The UUID is a 36 character string, including hyphens, and looks like this:\n * xxxxxxxx-xxxx-4xxx-axxx-xxxxxxxxxxxx\n *\n * Note that while UUIDs are not guaranteed to be unique, they are\n * practically unique\" given the large number of possible UUIDs and\n * the randomness of generation.\n *\n * @example\n * ```ts\n * const uuid = randomUuid();\n * console.log(uuid); // Outputs a version 4 UUID, e.g., '123e4567-e89b-12d3-a456-426655440000'\n * ```\n *\n * @returns A string containing a randomly generated, 36 character long v4 UUID.\n */\nexport function randomUuid(): string {\n  const uuid = crypto.randomUUID();\n\n  return uuid;\n}"],
  "mappings": "AAGO,IAAMA,EACX,OAAO,YAAe,UAAY,WAAY,WAAa,WAAW,OAAS,OCiC1E,IAAMC,EAAO,IAAI,WAAW,IAAI,YAAY,CAAC,SAAU,CAAC,EAAE,MAAM,EAAE,CAAC,IAAM,GAChF,GAAI,CAACA,EAAM,MAAM,IAAI,MAAM,6CAA6C,EAqJxE,IAAMC,EAAQ,CAAA,EAAG,SAgDX,SAAUC,EAAYC,EAAc,GAAE,CAC1C,GAAIC,GAAU,OAAOA,EAAO,iBAAoB,WAC9C,OAAOA,EAAO,gBAAgB,IAAI,WAAWD,CAAW,CAAC,EAE3D,MAAM,IAAI,MAAM,wCAAwC,CAC1D,CC3NO,SAASE,EAAsBC,EAG7B,CACP,GAAI,CAACA,GAAUA,EAAO,WAAa,QAAaA,EAAO,WAAa,OAClE,MAAM,IAAI,UAAU,iEAAiE,EAEvF,GAAM,CAAE,SAAAC,EAAU,SAAAC,CAAS,EAAIF,EAC/B,GAAI,EAAEC,KAAYC,GAChB,MAAM,IAAI,UAAU,gCAAgCD,CAAQ,GAAG,CAEnE,CAkBO,SAASE,EAAmBH,EAE1B,CACP,GAAI,CAACA,GAAUA,EAAO,WAAa,QAAaA,EAAO,oBAAsB,OAC3E,MAAM,IAAI,UAAU,wEAAwE,EAE9F,GAAM,CAAE,SAAAC,EAAU,kBAAAG,CAAkB,EAAIJ,EACxC,GACG,MAAM,QAAQI,CAAiB,GAAK,CAACA,EAAkB,SAASH,CAAQ,GACxEG,aAA6B,KAAO,CAACA,EAAkB,IAAIH,CAAQ,GACnEG,aAA6B,KAAO,CAACA,EAAkB,IAAIH,CAAQ,EACpE,CACA,IAAMI,EAAkB,MAAM,KAAMD,aAA6B,IAAOA,EAAkB,KAAK,EAAIA,CAAiB,EAAE,KAAK,IAAI,EAC/H,MAAM,IAAI,UAAU,kBAAkBH,CAAQ,sBAAsBI,CAAe,GAAG,CACxF,CACF,CA2BO,SAASC,EAAuCC,EAAwB,CAC7E,IAAMC,EAA+C,CACnD,QAAc,QACd,QAAc,QACd,QAAc,QACd,QAAc,QACd,UAAc,QAChB,EAIA,GAAID,EAAU,KAAO,OAAO,OAAOC,CAAoB,EAAE,SAASD,EAAU,GAAG,EAC7E,OAAOA,EAAU,IAInB,GAAIA,EAAU,KAAO,OAAO,KAAKC,CAAoB,EAAE,SAASD,EAAU,GAAG,EAC3E,OAAOC,EAAqBD,EAAU,GAAG,EAG3C,MAAM,IAAI,MACR,8DAA8DA,EAAU,GAAG,SAASA,EAAU,GAAG,6BACtE,OAAO,OAAOC,CAAoB,EAAE,KAAK,IAAI,CAAC,6BAC9C,OAAO,KAAKA,CAAoB,EAAE,KAAK,IAAI,CAAC,GACzE,CACF,CA6BO,SAASC,GAAgC,CAC9C,MAAI,cAAW,QAAU,WAAW,OAAO,OAK7C,CAsBO,SAASC,EAAYC,EAAiC,CAC3D,OAAOD,EAAiBC,CAAW,CACrC,CA2BO,SAASC,GAAqB,CAGnC,OAFaC,EAAO,WAAW,CAGjC",
  "names": ["crypto", "isLE", "toStr", "randomBytes", "bytesLength", "crypto", "checkRequiredProperty", "params", "property", "inObject", "checkValidProperty", "allowedProperties", "validProperties", "getJoseSignatureAlgorithmFromPublicKey", "publicKey", "curveToJoseAlgorithm", "isWebCryptoSupported", "randomBytes", "bytesLength", "randomUuid", "crypto"]
}
