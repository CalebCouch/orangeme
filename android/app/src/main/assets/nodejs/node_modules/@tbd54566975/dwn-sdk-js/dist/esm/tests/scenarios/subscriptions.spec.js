var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import freeForAll from '../vectors/protocol-definitions/free-for-all.json' assert { type: 'json' };
import threadProtocol from '../vectors/protocol-definitions/thread-role.json' assert { type: 'json' };
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestEventStream } from '../test-event-stream.js';
import { TestStores } from '../test-stores.js';
import { Time } from '../../src/utils/time.js';
import { DidKey, UniversalResolver } from '@web5/dids';
import { Dwn, DwnConstant, DwnInterfaceName, DwnMethodName, Message } from '../../src/index.js';
import { expect } from 'chai';
export function testSubscriptionScenarios() {
    describe('subscriptions', () => {
        let didResolver;
        let messageStore;
        let dataStore;
        let eventLog;
        let eventStream;
        let dwn;
        // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
        // so that different test suites can reuse the same backend store for testing
        before(() => __awaiter(this, void 0, void 0, function* () {
            didResolver = new UniversalResolver({ didResolvers: [DidKey] });
            const stores = TestStores.get();
            messageStore = stores.messageStore;
            dataStore = stores.dataStore;
            eventLog = stores.eventLog;
            eventStream = TestEventStream.get();
            dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog, eventStream });
        }));
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
            yield messageStore.clear();
            yield dataStore.clear();
            yield eventLog.clear();
        }));
        after(() => __awaiter(this, void 0, void 0, function* () {
            yield dwn.close();
        }));
        describe('events subscribe', () => {
            it('all events', () => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // create a handler that adds the messageCid of each message to an array.
                const messageCids = [];
                const handler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    const messageCid = yield Message.getCid(message);
                    messageCids.push(messageCid);
                });
                // subscribe to all messages
                const eventsSubscription = yield TestDataGenerator.generateEventsSubscribe({ author: alice });
                const eventsSubscriptionReply = yield dwn.processMessage(alice.did, eventsSubscription.message, { subscriptionHandler: handler });
                expect(eventsSubscriptionReply.status.code).to.equal(200);
                expect((_a = eventsSubscriptionReply.subscription) === null || _a === void 0 ? void 0 : _a.id).to.equal(yield Message.getCid(eventsSubscription.message));
                // generate various messages
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const write1MessageCid = yield Message.getCid(write1.message);
                const write1Reply = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                expect(write1Reply.status.code).to.equal(202);
                const protocol1 = yield TestDataGenerator.generateProtocolsConfigure({ author: alice });
                const protocol1MessageCid = yield Message.getCid(protocol1.message);
                const protocol1Reply = yield dwn.processMessage(alice.did, protocol1.message);
                expect(protocol1Reply.status.code).to.equal(202);
                const deleteWrite1 = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: write1.message.recordId });
                const delete1MessageCid = yield Message.getCid(deleteWrite1.message);
                const deleteWrite1Reply = yield dwn.processMessage(alice.did, deleteWrite1.message);
                expect(deleteWrite1Reply.status.code).to.equal(202);
                // unregister the handler
                yield ((_b = eventsSubscriptionReply.subscription) === null || _b === void 0 ? void 0 : _b.close());
                // create a message after
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const write2Reply = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                expect(write2Reply.status.code).to.equal(202);
                yield Time.minimalSleep();
                // test the messageCids array for the appropriate messages
                expect(messageCids.length).to.equal(3);
                expect(messageCids).to.eql([write1MessageCid, protocol1MessageCid, delete1MessageCid]);
            }));
            it('filters by interface type', () => __awaiter(this, void 0, void 0, function* () {
                // scenario:
                // alice subscribes to 2 different message interfaces (Records, Grants)
                // alice creates (2) messages, (RecordsWrite and ProtocolsConfigure)
                // alice checks that each handler emitted the appropriate message
                // alice deletes the record, and revokes the grant
                // alice checks that the Records and Protocols handlers emitted the appropriate message
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // subscribe to records
                const recordsInterfaceSubscription = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [{ interface: DwnInterfaceName.Records }]
                });
                const recordsMessageCids = [];
                const recordsSubscribeHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    const messageCid = yield Message.getCid(message);
                    recordsMessageCids.push(messageCid);
                });
                const recordsInterfaceSubscriptionReply = yield dwn.processMessage(alice.did, recordsInterfaceSubscription.message, { subscriptionHandler: recordsSubscribeHandler });
                expect(recordsInterfaceSubscriptionReply.status.code).to.equal(200);
                expect(recordsInterfaceSubscriptionReply.subscription).to.exist;
                // subscribe to protocols
                const protocolsInterfaceSubscription = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [{ interface: DwnInterfaceName.Protocols }]
                });
                const protocolsMessageCids = [];
                const protocolsSubscribeHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    const messageCid = yield Message.getCid(message);
                    protocolsMessageCids.push(messageCid);
                });
                const protocolsInterfaceSubscriptionReply = yield dwn.processMessage(alice.did, protocolsInterfaceSubscription.message, { subscriptionHandler: protocolsSubscribeHandler });
                expect(protocolsInterfaceSubscriptionReply.status.code).to.equal(200);
                expect(protocolsInterfaceSubscriptionReply.subscription).to.exist;
                // create one of each message types
                const record = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const protocol = yield TestDataGenerator.generateProtocolsConfigure({ author: alice });
                // insert data
                const recordReply = yield dwn.processMessage(alice.did, record.message, { dataStream: record.dataStream });
                const protocolReply = yield dwn.processMessage(alice.did, protocol.message);
                expect(recordReply.status.code).to.equal(202, 'RecordsWrite');
                expect(protocolReply.status.code).to.equal(202, 'ProtocolConfigure');
                // check record message
                expect(recordsMessageCids.length).to.equal(1);
                expect(recordsMessageCids).to.have.members([yield Message.getCid(record.message)]);
                // check protocols message
                expect(protocolsMessageCids.length).to.equal(1);
                expect(protocolsMessageCids).to.have.members([yield Message.getCid(protocol.message)]);
                // insert additional data to query beyond a cursor
                const recordDelete = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: record.message.recordId });
                const recordDeleteReply = yield dwn.processMessage(alice.did, recordDelete.message);
                expect(recordDeleteReply.status.code).to.equal(202, 'RecordsDelete');
                // check record messages to include the delete message
                expect(recordsMessageCids.length).to.equal(2);
                expect(recordsMessageCids).to.include.members([yield Message.getCid(recordDelete.message)]);
                // protocols remains unchanged
                expect(protocolsMessageCids.length).to.equal(1);
            }));
            it('filters by method type', () => __awaiter(this, void 0, void 0, function* () {
                // scenario:
                // alice creates a variety of Messages (RecordsWrite, RecordsDelete, ProtocolConfigure)
                // alice queries for only RecordsWrite messages
                // alice creates more messages to query beyond a cursor
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // subscribe to records write
                const recordsWriteSubscription = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [{ interface: DwnInterfaceName.Records, method: DwnMethodName.Write }]
                });
                const recordsMessageCids = [];
                const recordsSubscribeHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    const messageCid = yield Message.getCid(message);
                    recordsMessageCids.push(messageCid);
                });
                const recordsWriteSubscriptionReply = yield dwn.processMessage(alice.did, recordsWriteSubscription.message, { subscriptionHandler: recordsSubscribeHandler });
                expect(recordsWriteSubscriptionReply.status.code).to.equal(200);
                expect(recordsWriteSubscriptionReply.subscription).to.exist;
                // create one of each message types
                const record = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                // insert data
                const recordReply = yield dwn.processMessage(alice.did, record.message, { dataStream: record.dataStream });
                expect(recordReply.status.code).to.equal(202, 'RecordsWrite');
                // sleep to make sure event was processed and added to array asynchronously
                yield Time.minimalSleep();
                // check record message
                expect(recordsMessageCids.length).to.equal(1);
                expect(recordsMessageCids).to.have.members([yield Message.getCid(record.message)]);
                // delete the message
                const recordDelete = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: record.message.recordId });
                const recordDeleteReply = yield dwn.processMessage(alice.did, recordDelete.message);
                expect(recordDeleteReply.status.code).to.equal(202, 'RecordsDelete');
                // check record messages remain unchanged and do not include the delete since we only subscribe to writes
                expect(recordsMessageCids.length).to.equal(1);
            }));
            it('filters by a protocol across different message types', () => __awaiter(this, void 0, void 0, function* () {
                // scenario:
                //    alice creates (3) different message types all related to "proto1" (Configure, RecordsWrite, RecordsDelete)
                //    alice creates (3) different message types all related to "proto2" (Configure, RecordsWrite, RecordsDelete)
                //    when subscribing for a specific protocol, only Messages related to it should be emitted.
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const proto1Messages = [];
                const proto1Handler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    proto1Messages.push(yield Message.getCid(message));
                });
                const proto1Subscription = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [{ protocol: 'http://proto1' }]
                });
                const proto1SubscriptionReply = yield dwn.processMessage(alice.did, proto1Subscription.message, {
                    subscriptionHandler: proto1Handler
                });
                expect(proto1SubscriptionReply.status.code).to.equal(200);
                expect(proto1SubscriptionReply.subscription).to.exist;
                const proto2Messages = [];
                const proto2Handler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    proto2Messages.push(yield Message.getCid(message));
                });
                const proto2Subscription = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [{ protocol: 'http://proto2' }]
                });
                const proto2SubscriptionReply = yield dwn.processMessage(alice.did, proto2Subscription.message, {
                    subscriptionHandler: proto2Handler
                });
                expect(proto2SubscriptionReply.status.code).to.equal(200);
                expect(proto2SubscriptionReply.subscription).to.exist;
                // create a proto1
                const protoConf1 = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition: Object.assign(Object.assign({}, freeForAll), { protocol: 'http://proto1' })
                });
                const postProperties = {
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                };
                const proto1 = protoConf1.message.descriptor.definition.protocol;
                const protoConf1Response = yield dwn.processMessage(alice.did, protoConf1.message);
                expect(protoConf1Response.status.code).equals(202);
                // create a proto2
                const protoConf2 = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition: Object.assign(Object.assign({}, freeForAll), { protocol: 'http://proto2' })
                });
                const proto2 = protoConf2.message.descriptor.definition.protocol;
                const protoConf2Response = yield dwn.processMessage(alice.did, protoConf2.message);
                expect(protoConf2Response.status.code).equals(202);
                // create a record for proto1
                const write1proto1 = yield TestDataGenerator.generateRecordsWrite(Object.assign({ author: alice, protocol: proto1 }, postProperties));
                const write1Response = yield dwn.processMessage(alice.did, write1proto1.message, { dataStream: write1proto1.dataStream });
                expect(write1Response.status.code).equals(202);
                // create a record for proto2
                const write1proto2 = yield TestDataGenerator.generateRecordsWrite(Object.assign({ author: alice, protocol: proto2 }, postProperties));
                const write1Proto2Response = yield dwn.processMessage(alice.did, write1proto2.message, { dataStream: write1proto2.dataStream });
                expect(write1Proto2Response.status.code).equals(202);
                // check for proto1 messages
                expect(proto1Messages.length).to.equal(2);
                expect(proto1Messages).to.have.members([yield Message.getCid(protoConf1.message), yield Message.getCid(write1proto1.message)]);
                // check for proto2 messages
                expect(proto2Messages.length).to.equal(2);
                expect(proto2Messages).to.have.members([yield Message.getCid(protoConf2.message), yield Message.getCid(write1proto2.message)]);
                // delete proto1 message
                const deleteProto1Message = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: write1proto1.message.recordId });
                const deleteProto1MessageReply = yield dwn.processMessage(alice.did, deleteProto1Message.message);
                expect(deleteProto1MessageReply.status.code).to.equal(202);
                // delete proto2 message
                const deleteProto2Message = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: write1proto2.message.recordId });
                const deleteProto2MessageReply = yield dwn.processMessage(alice.did, deleteProto2Message.message);
                expect(deleteProto2MessageReply.status.code).to.equal(202);
                // check for the delete in proto1 messages
                expect(proto1Messages.length).to.equal(3);
                expect(proto1Messages).to.include.members([yield Message.getCid(deleteProto1Message.message)]);
                // check for the delete in proto2 messages
                expect(proto2Messages.length).to.equal(3);
                expect(proto2Messages).to.include.members([yield Message.getCid(deleteProto2Message.message)]);
            }));
            it('filters by protocol & parentId across multiple protocolPaths', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: subscribe to multiple protocolPaths for a given protocol and parentId
                //    alice installs a protocol and creates a thread
                //    alice subscribes to update to that thread, it's participant as well as thread chats
                //    alice adds bob and carol as participants to the thread
                //    alice, bob, and carol all create messages
                //    alice deletes carol participant message
                //    alice checks that the correct messages were omitted
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const carol = yield TestDataGenerator.generateDidKeyPersona();
                // create protocol
                const protocolConfigure = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition: Object.assign({}, threadProtocol)
                });
                const protocolConfigureReply = yield dwn.processMessage(alice.did, protocolConfigure.message);
                expect(protocolConfigureReply.status.code).to.equal(202);
                const protocol = protocolConfigure.message.descriptor.definition.protocol;
                // alice creates thread
                const thread = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    protocol: protocol,
                    protocolPath: 'thread'
                });
                const threadReply = yield dwn.processMessage(alice.did, thread.message, { dataStream: thread.dataStream });
                expect(threadReply.status.code).to.equal(202);
                // subscribe to this thread's events
                const messages = [];
                const subscriptionHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    messages.push(yield Message.getCid(message));
                });
                const threadSubscription = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [
                        { protocol: protocol, protocolPath: 'thread', parentId: thread.message.recordId },
                        { protocol: protocol, protocolPath: 'thread/participant', parentId: thread.message.recordId },
                        { protocol: protocol, protocolPath: 'thread/chat', parentId: thread.message.recordId } // chat updates
                    ],
                });
                const threadSubscriptionReply = yield dwn.processMessage(alice.did, threadSubscription.message, {
                    subscriptionHandler
                });
                expect(threadSubscriptionReply.status.code).to.equal(200);
                expect(threadSubscriptionReply.subscription).to.exist;
                // add bob as participant
                const bobParticipant = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: bob.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/participant'
                });
                const bobParticipantReply = yield dwn.processMessage(alice.did, bobParticipant.message, { dataStream: bobParticipant.dataStream });
                expect(bobParticipantReply.status.code).to.equal(202);
                // add carol as participant
                const carolParticipant = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: carol.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/participant'
                });
                const carolParticipantReply = yield dwn.processMessage(alice.did, carolParticipant.message, { dataStream: carolParticipant.dataStream });
                expect(carolParticipantReply.status.code).to.equal(202);
                // add another thread as a control, will not show up in handled events
                const additionalThread = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    protocol: protocol,
                    protocolPath: 'thread'
                });
                const additionalThreadReply = yield dwn.processMessage(alice.did, additionalThread.message, { dataStream: additionalThread.dataStream });
                expect(additionalThreadReply.status.code).to.equal(202);
                // sleep to allow all messages to be processed by the handler message
                yield Time.minimalSleep();
                expect(messages.length).to.equal(2);
                expect(messages).to.have.members([
                    yield Message.getCid(bobParticipant.message),
                    yield Message.getCid(carolParticipant.message),
                ]);
                // add a message to protocol1
                const message1 = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: alice.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/chat',
                    protocolRole: 'thread/participant',
                });
                const message1Reply = yield dwn.processMessage(alice.did, message1.message, { dataStream: message1.dataStream });
                expect(message1Reply.status.code).to.equal(202);
                const message2 = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: alice.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/chat',
                    protocolRole: 'thread/participant',
                });
                const message2Reply = yield dwn.processMessage(alice.did, message2.message, { dataStream: message2.dataStream });
                expect(message2Reply.status.code).to.equal(202);
                const message3 = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: alice.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/chat',
                    protocolRole: 'thread/participant',
                });
                const message3Reply = yield dwn.processMessage(alice.did, message3.message, { dataStream: message3.dataStream });
                expect(message3Reply.status.code).to.equal(202);
                // sleep in order to allow messages to process and check for the added messages
                yield Time.minimalSleep();
                expect(messages.length).to.equal(5);
                expect(messages).to.include.members([
                    yield Message.getCid(message1.message),
                    yield Message.getCid(message2.message),
                    yield Message.getCid(message3.message),
                ]);
                // delete carol participant
                const deleteCarol = yield TestDataGenerator.generateRecordsDelete({
                    author: alice,
                    recordId: carolParticipant.message.recordId
                });
                const deleteCarolReply = yield dwn.processMessage(alice.did, deleteCarol.message);
                expect(deleteCarolReply.status.code).to.equal(202);
                // sleep in order to allow messages to process and check for the delete message
                yield Time.minimalSleep();
                expect(messages.length).to.equal(6);
                expect(messages).to.include.members([
                    yield Message.getCid(deleteCarol.message)
                ]);
            }));
            it('filters by schema', () => __awaiter(this, void 0, void 0, function* () {
                var _c, _d, _e;
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // we will add messageCids to these arrays as they are received by their handler to check against later
                const schema1Messages = [];
                const schema2Messages = [];
                // we add a handler to the subscription and add the messageCid to the appropriate array
                const schema1Handler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    const messageCid = yield Message.getCid(message);
                    schema1Messages.push(messageCid);
                });
                // subscribe to schema1 messages
                const schema1Subscription = yield TestDataGenerator.generateEventsSubscribe({ author: alice, filters: [{ schema: 'http://schema1' }] });
                const schema1SubscriptionReply = yield dwn.processMessage(alice.did, schema1Subscription.message, { subscriptionHandler: schema1Handler });
                expect(schema1SubscriptionReply.status.code).to.equal(200);
                expect((_c = schema1SubscriptionReply.subscription) === null || _c === void 0 ? void 0 : _c.id).to.equal(yield Message.getCid(schema1Subscription.message));
                // we add a handler to the subscription and add the messageCid to the appropriate array
                const schema2Handler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    const messageCid = yield Message.getCid(message);
                    schema2Messages.push(messageCid);
                });
                // subscribe to schema2 messages
                const schema2Subscription = yield TestDataGenerator.generateEventsSubscribe({ author: alice, filters: [{ schema: 'http://schema2' }] });
                const schema2SubscriptionReply = yield dwn.processMessage(alice.did, schema2Subscription.message, { subscriptionHandler: schema2Handler });
                expect(schema2SubscriptionReply.status.code).to.equal(200);
                expect((_d = schema2SubscriptionReply.subscription) === null || _d === void 0 ? void 0 : _d.id).to.equal(yield Message.getCid(schema2Subscription.message));
                // create some random record, will not show up in records subscription
                const write1Random = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const write1RandomResponse = yield dwn.processMessage(alice.did, write1Random.message, { dataStream: write1Random.dataStream });
                expect(write1RandomResponse.status.code).to.equal(202);
                // create a record for schema1
                const write1schema1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema1' });
                const write1Response = yield dwn.processMessage(alice.did, write1schema1.message, { dataStream: write1schema1.dataStream });
                expect(write1Response.status.code).equals(202);
                // create a record for schema2
                const write1schema2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema2' });
                const write1Proto2Response = yield dwn.processMessage(alice.did, write1schema2.message, { dataStream: write1schema2.dataStream });
                expect(write1Proto2Response.status.code).equals(202);
                expect(schema1Messages.length).to.equal(1, 'schema1');
                expect(schema1Messages).to.include(yield Message.getCid(write1schema1.message));
                expect(schema2Messages.length).to.equal(1, 'schema2');
                expect(schema2Messages).to.include(yield Message.getCid(write1schema2.message));
                // remove listener for schema1
                (_e = schema1SubscriptionReply.subscription) === null || _e === void 0 ? void 0 : _e.close();
                // create another record for schema1
                const write2proto1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema1' });
                const write2Response = yield dwn.processMessage(alice.did, write2proto1.message, { dataStream: write2proto1.dataStream });
                expect(write2Response.status.code).equals(202);
                // create another record for schema2
                const write2schema2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema2' });
                const write2Schema2Response = yield dwn.processMessage(alice.did, write2schema2.message, { dataStream: write2schema2.dataStream });
                expect(write2Schema2Response.status.code).equals(202);
                // schema1 messages from handler do not change.
                expect(schema1Messages.length).to.equal(1, 'schema1 after close()');
                expect(schema1Messages).to.include(yield Message.getCid(write1schema1.message));
                // schema2 messages from handler have the new message.
                expect(schema2Messages.length).to.equal(2, 'schema2 after close()');
                expect(schema2Messages).to.have.members([yield Message.getCid(write1schema2.message), yield Message.getCid(write2schema2.message)]);
            }));
            it('filters by recordId', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const write = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    schema: 'schema1'
                });
                const write1Reply = yield dwn.processMessage(alice.did, write.message, { dataStream: write.dataStream });
                expect(write1Reply.status.code).to.equal(202);
                // create a subscription and capture the messages associated with the record
                const messages = [];
                const subscriptionHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    messages.push(yield Message.getCid(message));
                });
                const recordIdSubscribe = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [{ recordId: write.message.recordId }]
                });
                const recordIdSubscribeReply = yield dwn.processMessage(alice.did, recordIdSubscribe.message, {
                    subscriptionHandler
                });
                expect(recordIdSubscribeReply.status.code).to.equal(200);
                // a write as a control, will not show up in subscription
                const controlWrite = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    schema: 'schema1'
                });
                const write2Reply = yield dwn.processMessage(alice.did, controlWrite.message, { dataStream: controlWrite.dataStream });
                expect(write2Reply.status.code).to.equal(202);
                // update record
                const update = yield TestDataGenerator.generateFromRecordsWrite({
                    author: alice,
                    existingWrite: write.recordsWrite,
                });
                const updateReply = yield dwn.processMessage(alice.did, update.message, { dataStream: update.dataStream });
                expect(updateReply.status.code).to.equal(202);
                // sleep to allow all messages to be processed by the handler message
                yield Time.minimalSleep();
                expect(messages.length).to.equal(1);
                expect(messages).to.have.members([yield Message.getCid(update.message)]);
                const deleteRecord = yield TestDataGenerator.generateRecordsDelete({
                    author: alice,
                    recordId: write.message.recordId,
                });
                const deleteRecordReply = yield dwn.processMessage(alice.did, deleteRecord.message);
                expect(deleteRecordReply.status.code).to.equal(202);
                // sleep to allow all messages to be processed by the handler message
                yield Time.minimalSleep();
                expect(messages.length).to.equal(2);
                expect(messages).to.include.members([yield Message.getCid(deleteRecord.message)]);
            }));
            it('filters by recipient', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const carol = yield TestDataGenerator.generateDidKeyPersona();
                const receivedMessages = [];
                const handler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    const messageCid = yield Message.getCid(message);
                    receivedMessages.push(messageCid);
                });
                const recipientSubscription = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [{ recipient: alice.did }]
                });
                const authorQueryReply = yield dwn.processMessage(alice.did, recipientSubscription.message, { subscriptionHandler: handler });
                expect(authorQueryReply.status.code).to.equal(200);
                const protocolConfigure = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition: Object.assign({}, freeForAll)
                });
                const protocolConfigureReply = yield dwn.processMessage(alice.did, protocolConfigure.message);
                expect(protocolConfigureReply.status.code).to.equal(202);
                const protocol = protocolConfigure.message.descriptor.definition.protocol;
                const postProperties = {
                    protocol: protocol,
                    protocolPath: 'post',
                    schema: freeForAll.types.post.schema,
                    dataFormat: freeForAll.types.post.dataFormats[0],
                };
                const messageFromBobToAlice = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: bob, recipient: alice.did }));
                const messageFromBobToAliceReply = yield dwn.processMessage(alice.did, messageFromBobToAlice.message, { dataStream: messageFromBobToAlice.dataStream });
                expect(messageFromBobToAliceReply.status.code).to.equal(202);
                const messageFromCarolToAlice = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: carol, recipient: alice.did }));
                const messageFromCarolToAliceReply = yield dwn.processMessage(alice.did, messageFromCarolToAlice.message, { dataStream: messageFromCarolToAlice.dataStream });
                expect(messageFromCarolToAliceReply.status.code).to.equal(202);
                const messageFromAliceToBob = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: alice, recipient: bob.did }));
                const messageFromAliceToBobReply = yield dwn.processMessage(alice.did, messageFromAliceToBob.message, { dataStream: messageFromAliceToBob.dataStream });
                expect(messageFromAliceToBobReply.status.code).to.equal(202);
                const messageFromAliceToCarol = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: alice, recipient: carol.did }));
                const messageFromAliceToCarolReply = yield dwn.processMessage(alice.did, messageFromAliceToCarol.message, { dataStream: messageFromAliceToCarol.dataStream });
                expect(messageFromAliceToCarolReply.status.code).to.equal(202);
                expect(receivedMessages).to.have.members([
                    yield Message.getCid(messageFromBobToAlice.message),
                    yield Message.getCid(messageFromCarolToAlice.message)
                ]);
                // add another message
                const messageFromAliceToBob2 = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: alice, recipient: bob.did }));
                const messageFromAliceToBob2Reply = yield dwn.processMessage(alice.did, messageFromAliceToBob2.message, { dataStream: messageFromAliceToBob2.dataStream });
                expect(messageFromAliceToBob2Reply.status.code).to.equal(202);
                expect(receivedMessages).to.not.include.members([yield Message.getCid(messageFromAliceToBob2.message)]);
            }));
            it('filters by dataFormat', () => __awaiter(this, void 0, void 0, function* () {
                // Scenario: Alice subscribes events relating to `image/jpeg` after which a number of record messages of various data formats are processed
                // 1. Alice subscribes for `image/jpeg` records
                // 2. Alice creates 3 files, one of them `image/jpeg`
                // 3. Alice receives the one `image/jpeg` message
                // 4. Alice adds another image
                // 5. Alice receives the other `image/jpeg` message
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const imageMessages = [];
                const imageHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    imageMessages.push(yield Message.getCid(message));
                });
                // alice subscribes to image/jpeg changes
                const imageSubscription = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [{ dataFormat: 'image/jpeg' }]
                });
                const imageSubscriptionReply = yield dwn.processMessage(alice.did, imageSubscription.message, {
                    subscriptionHandler: imageHandler
                });
                expect(imageSubscriptionReply.status.code).to.equal(200);
                // write a text file
                const textFile = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    dataFormat: 'application/text'
                });
                const textFileReply = yield dwn.processMessage(alice.did, textFile.message, { dataStream: textFile.dataStream });
                expect(textFileReply.status.code).to.equal(202);
                // write an application/json file
                const jsonData = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    dataFormat: 'application/json'
                });
                const jsonDataReply = yield dwn.processMessage(alice.did, jsonData.message, { dataStream: jsonData.dataStream });
                expect(jsonDataReply.status.code).to.equal(202);
                // write an image
                const imageData = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    dataFormat: 'image/jpeg'
                });
                const imageDataReply = yield dwn.processMessage(alice.did, imageData.message, { dataStream: imageData.dataStream });
                expect(imageDataReply.status.code).to.equal(202);
                // wait for messages to emit and handler to process
                yield Time.minimalSleep();
                expect(imageMessages.length).to.equal(1);
                expect(imageMessages).to.have.members([yield Message.getCid(imageData.message)]);
                // add another image
                const imageData2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    dataFormat: 'image/jpeg'
                });
                const imageData2Reply = yield dwn.processMessage(alice.did, imageData2.message, { dataStream: imageData2.dataStream });
                expect(imageData2Reply.status.code).to.equal(202);
                // wait for messages to emit and handler to process
                yield Time.minimalSleep();
                expect(imageMessages.length).to.equal(2);
                // check that the new image and the delete messages were emitted
                expect(imageMessages).to.include.members([
                    yield Message.getCid(imageData2.message)
                ]);
            }));
            ;
            it('filters by dataSize', () => __awaiter(this, void 0, void 0, function* () {
                // scenario:
                //    alice subscribes to messages with data size under a threshold
                //    alice inserts both small and large data
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const smallMessages = [];
                const subscriptionHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    smallMessages.push(yield Message.getCid(message));
                });
                const smallMessageSubscription = yield TestDataGenerator.generateEventsSubscribe({
                    author: alice,
                    filters: [{ dataSize: { lte: DwnConstant.maxDataSizeAllowedToBeEncoded } }]
                });
                const smallMessageSubscriptionReply = yield dwn.processMessage(alice.did, smallMessageSubscription.message, {
                    subscriptionHandler,
                });
                expect(smallMessageSubscriptionReply.status.code).to.equal(200);
                // add a small data size record
                const smallSize1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                });
                const smallSize1Reply = yield dwn.processMessage(alice.did, smallSize1.message, { dataStream: smallSize1.dataStream });
                expect(smallSize1Reply.status.code).to.equal(202);
                // add a large data size record
                const largeSize = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    data: TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded + 1)
                });
                const largeSizeReply = yield dwn.processMessage(alice.did, largeSize.message, { dataStream: largeSize.dataStream });
                expect(largeSizeReply.status.code).to.equal(202);
                // wait for message handler to process and check results
                yield Time.minimalSleep();
                expect(smallMessages.length).to.equal(1);
                expect(smallMessages).to.have.members([yield Message.getCid(smallSize1.message)]);
                // add another small record
                const smallSize2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                });
                const smallSize2Reply = yield dwn.processMessage(alice.did, smallSize2.message, { dataStream: smallSize2.dataStream });
                expect(smallSize2Reply.status.code).to.equal(202);
                // add another large record
                const largeSize2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    data: TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded + 1)
                });
                const largeSize2Reply = yield dwn.processMessage(alice.did, largeSize2.message, { dataStream: largeSize2.dataStream });
                expect(largeSize2Reply.status.code).to.equal(202);
                // wait for message handler to process and check results
                yield Time.minimalSleep();
                expect(smallMessages.length).to.equal(2);
                expect(smallMessages).to.include.members([yield Message.getCid(smallSize2.message)]);
            }));
            it('does not emit events after subscription is closed', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // messageCids of events
                const messageCids = [];
                const handler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    const messageCid = yield Message.getCid(message);
                    messageCids.push(messageCid);
                });
                // subscribe to all events
                const eventsSubscription = yield TestDataGenerator.generateEventsSubscribe({ author: alice });
                const eventsSubscriptionReply = yield dwn.processMessage(alice.did, eventsSubscription.message, { subscriptionHandler: handler });
                expect(eventsSubscriptionReply.status.code).to.equal(200);
                expect(messageCids.length).to.equal(0); // no events exist yet
                const record1 = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const record1Reply = yield dwn.processMessage(alice.did, record1.message, { dataStream: record1.dataStream });
                expect(record1Reply.status.code).to.equal(202);
                const record1MessageCid = yield Message.getCid(record1.message);
                expect(messageCids.length).to.equal(1); // message exists
                expect(messageCids).to.eql([record1MessageCid]);
                // unsubscribe, this should be used as clean up.
                yield eventsSubscriptionReply.subscription.close();
                // write another message.
                const record2 = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const record2Reply = yield dwn.processMessage(alice.did, record2.message, { dataStream: record2.dataStream });
                expect(record2Reply.status.code).to.equal(202);
                // sleep to make sure events have some time to emit.
                yield Time.minimalSleep();
                expect(messageCids.length).to.equal(1); // same as before
                expect(messageCids).to.eql([record1MessageCid]);
            }));
        });
        describe('records subscribe', () => {
            it('allows for anonymous subscriptions to published records', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const messages = [];
                const subscriptionHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    messages.push(yield Message.getCid(message));
                });
                const anonymousSubscription = yield TestDataGenerator.generateRecordsSubscribe({
                    anonymous: true,
                    filter: { schema: 'http://schema1' }
                });
                const anonymousSubscriptionReply = yield dwn.processMessage(alice.did, anonymousSubscription.message, {
                    subscriptionHandler
                });
                expect(anonymousSubscriptionReply.status.code).to.equal(200);
                expect(anonymousSubscriptionReply.subscription).to.exist;
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema1', published: true });
                const write1Reply = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                expect(write1Reply.status.code).to.equal(202);
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema1', published: true });
                const write2Reply = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                expect(write2Reply.status.code).to.equal(202);
                // will not be emitted as it is not explicitly published
                const writeNotPublished = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema1' });
                const writeNotPublishedReply = yield dwn.processMessage(alice.did, writeNotPublished.message, { dataStream: writeNotPublished.dataStream });
                expect(writeNotPublishedReply.status.code).to.equal(202);
                // await for handler to receive and process the message
                yield Time.minimalSleep();
                expect(messages.length).to.equal(2);
                expect(messages).to.have.members([
                    yield Message.getCid(write1.message),
                    yield Message.getCid(write2.message),
                ]);
            }));
            it('allows authorized subscriptions to records intended for a recipient', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const carol = yield TestDataGenerator.generateDidKeyPersona();
                // bob subscribes to any messages he's authorized to see
                const bobMessages = [];
                const bobSubscribeHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    bobMessages.push(yield Message.getCid(message));
                });
                const bobSubscribe = yield TestDataGenerator.generateRecordsSubscribe({
                    author: bob,
                    filter: { schema: 'http://schema1' }
                });
                const bobSubscribeReply = yield dwn.processMessage(alice.did, bobSubscribe.message, {
                    subscriptionHandler: bobSubscribeHandler
                });
                expect(bobSubscribeReply.status.code).to.equal(200);
                expect(bobSubscribeReply.subscription).to.exist;
                // carol subscribes to any messages she's the recipient of.
                const carolMessages = [];
                const carolSubscribeHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message } = event;
                    carolMessages.push(yield Message.getCid(message));
                });
                const carolSubscribe = yield TestDataGenerator.generateRecordsSubscribe({
                    author: carol,
                    filter: { schema: 'http://schema1', recipient: carol.did }
                });
                const carolSubscribeReply = yield dwn.processMessage(alice.did, carolSubscribe.message, {
                    subscriptionHandler: carolSubscribeHandler
                });
                expect(carolSubscribeReply.status.code).to.equal(200);
                expect(carolSubscribeReply.subscription).to.exist;
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema1', recipient: bob.did });
                const write1Reply = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
                expect(write1Reply.status.code).to.equal(202);
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema1', recipient: bob.did });
                const write2Reply = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
                expect(write2Reply.status.code).to.equal(202);
                // message for carol only
                const writeForCarol = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'http://schema1', recipient: carol.did });
                const writeForCarolReply = yield dwn.processMessage(alice.did, writeForCarol.message, { dataStream: writeForCarol.dataStream });
                expect(writeForCarolReply.status.code).to.equal(202);
                // await for handler to receive and process the message
                yield Time.minimalSleep();
                expect(bobMessages.length).to.equal(2);
                expect(bobMessages).to.have.members([
                    yield Message.getCid(write1.message),
                    yield Message.getCid(write2.message),
                ]);
                expect(carolMessages.length).to.equal(1);
                expect(carolMessages).to.have.members([
                    yield Message.getCid(writeForCarol.message),
                ]);
            }));
            it('filters by protocol & parentId across multiple protocolPaths', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: subscribe to multiple protocolPaths for a given protocol and parentId
                //    alice installs a protocol and creates a thread
                //    alice subscribes to update to that thread, it's participant as well as thread chats
                //    alice adds bob and carol as participants to the thread
                //    alice, bob, and carol all create messages
                //    alice deletes carol participant message
                //    alice checks that the correct messages were omitted
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const carol = yield TestDataGenerator.generateDidKeyPersona();
                // create protocol
                const protocolConfigure = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition: Object.assign({}, threadProtocol)
                });
                const protocolConfigureReply = yield dwn.processMessage(alice.did, protocolConfigure.message);
                expect(protocolConfigureReply.status.code).to.equal(202);
                const protocol = protocolConfigure.message.descriptor.definition.protocol;
                // alice creates thread
                const thread = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    protocol: protocol,
                    protocolPath: 'thread'
                });
                const threadReply = yield dwn.processMessage(alice.did, thread.message, { dataStream: thread.dataStream });
                expect(threadReply.status.code).to.equal(202);
                // subscribe to this thread's events
                const messages = [];
                const initialWrites = [];
                const subscriptionHandler = (event) => __awaiter(this, void 0, void 0, function* () {
                    const { message, initialWrite } = event;
                    if (initialWrite !== undefined) {
                        initialWrites.push(yield Message.getCid(initialWrite));
                    }
                    messages.push(yield Message.getCid(message));
                });
                const threadSubscription = yield TestDataGenerator.generateRecordsSubscribe({
                    author: alice,
                    filter: { protocol: protocol, protocolPath: 'thread', parentId: thread.message.recordId }, // thread updates
                });
                const threadSubscriptionReply = yield dwn.processMessage(alice.did, threadSubscription.message, {
                    subscriptionHandler
                });
                expect(threadSubscriptionReply.status.code).to.equal(200);
                expect(threadSubscriptionReply.subscription).to.exist;
                const participantSubscription = yield TestDataGenerator.generateRecordsSubscribe({
                    author: alice,
                    filter: { protocol: protocol, protocolPath: 'thread/participant', parentId: thread.message.recordId }, // participant updates
                });
                const participantSubscriptionReply = yield dwn.processMessage(alice.did, participantSubscription.message, {
                    subscriptionHandler
                });
                expect(participantSubscriptionReply.status.code).to.equal(200);
                expect(participantSubscriptionReply.subscription).to.exist;
                const chatSubscription = yield TestDataGenerator.generateRecordsSubscribe({
                    author: alice,
                    filter: { protocol: protocol, protocolPath: 'thread/chat', parentId: thread.message.recordId } // chat updates
                });
                const chatSubscriptionReply = yield dwn.processMessage(alice.did, chatSubscription.message, {
                    subscriptionHandler
                });
                expect(chatSubscriptionReply.status.code).to.equal(200);
                expect(chatSubscriptionReply.subscription).to.exist;
                // add bob as participant
                const bobParticipant = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: bob.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/participant'
                });
                const bobParticipantReply = yield dwn.processMessage(alice.did, bobParticipant.message, { dataStream: bobParticipant.dataStream });
                expect(bobParticipantReply.status.code).to.equal(202);
                // add carol as participant
                const carolParticipant = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: carol.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/participant'
                });
                const carolParticipantReply = yield dwn.processMessage(alice.did, carolParticipant.message, { dataStream: carolParticipant.dataStream });
                expect(carolParticipantReply.status.code).to.equal(202);
                // add another thread as a control, will not show up in handled events
                const additionalThread = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    protocol: protocol,
                    protocolPath: 'thread'
                });
                const additionalThreadReply = yield dwn.processMessage(alice.did, additionalThread.message, { dataStream: additionalThread.dataStream });
                expect(additionalThreadReply.status.code).to.equal(202);
                // sleep to allow all messages to be processed by the handler message
                yield Time.minimalSleep();
                expect(messages.length).to.equal(2);
                expect(messages).to.have.members([
                    yield Message.getCid(bobParticipant.message),
                    yield Message.getCid(carolParticipant.message),
                ]);
                // add a message to protocol1
                const message1 = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: alice.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/chat',
                    protocolRole: 'thread/participant',
                });
                const message1Reply = yield dwn.processMessage(alice.did, message1.message, { dataStream: message1.dataStream });
                expect(message1Reply.status.code).to.equal(202);
                const message2 = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    recipient: alice.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/chat',
                    protocolRole: 'thread/participant',
                });
                const message2Reply = yield dwn.processMessage(alice.did, message2.message, { dataStream: message2.dataStream });
                expect(message2Reply.status.code).to.equal(202);
                const message3 = yield TestDataGenerator.generateRecordsWrite({
                    author: carol,
                    recipient: alice.did,
                    parentContextId: thread.message.contextId,
                    protocol: protocol,
                    protocolPath: 'thread/chat',
                    protocolRole: 'thread/participant',
                });
                const message3Reply = yield dwn.processMessage(alice.did, message3.message, { dataStream: message3.dataStream });
                expect(message3Reply.status.code).to.equal(202);
                // sleep in order to allow messages to process and check for the added messages
                yield Time.minimalSleep();
                expect(messages.length).to.equal(5);
                expect(messages).to.include.members([
                    yield Message.getCid(message1.message),
                    yield Message.getCid(message2.message),
                    yield Message.getCid(message3.message),
                ]);
                // delete carol participant
                const deleteCarol = yield TestDataGenerator.generateRecordsDelete({
                    author: alice,
                    recordId: carolParticipant.message.recordId
                });
                const deleteCarolReply = yield dwn.processMessage(alice.did, deleteCarol.message);
                expect(deleteCarolReply.status.code).to.equal(202);
                // sleep in order to allow messages to process and check for the delete message
                yield Time.minimalSleep();
                expect(messages.length).to.equal(6);
                expect(messages).to.include.members([
                    yield Message.getCid(deleteCarol.message)
                ]);
                // check the initial write was included with the delete
                expect(initialWrites).to.include.members([
                    yield Message.getCid(carolParticipant.message)
                ]);
            }));
        });
    });
}
//# sourceMappingURL=subscriptions.spec.js.map