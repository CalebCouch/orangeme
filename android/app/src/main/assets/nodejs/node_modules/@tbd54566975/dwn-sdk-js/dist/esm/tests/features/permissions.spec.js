var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import chaiAsPromised from 'chai-as-promised';
import sinon from 'sinon';
import chai, { expect } from 'chai';
import { DataStream } from '../../src/utils/data-stream.js';
import { Dwn } from '../../src/dwn.js';
import { Jws } from '../../src/utils/jws.js';
import { PermissionsProtocol } from '../../src/protocols/permissions.js';
import { RecordsRead } from '../../src/interfaces/records-read.js';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestEventStream } from '../test-event-stream.js';
import { TestStores } from '../test-stores.js';
import { DidKey, UniversalResolver } from '@web5/dids';
import { DwnErrorCode, DwnInterfaceName, DwnMethodName, Encoder, RecordsQuery, RecordsWrite, Time } from '../../src/index.js';
chai.use(chaiAsPromised);
export function testPermissions() {
    describe('permissions', () => __awaiter(this, void 0, void 0, function* () {
        let didResolver;
        let messageStore;
        let dataStore;
        let eventLog;
        let eventStream;
        let dwn;
        // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
        // so that different test suites can reuse the same backend store for testing
        before(() => __awaiter(this, void 0, void 0, function* () {
            didResolver = new UniversalResolver({ didResolvers: [DidKey] });
            const stores = TestStores.get();
            messageStore = stores.messageStore;
            dataStore = stores.dataStore;
            eventLog = stores.eventLog;
            eventStream = TestEventStream.get();
            dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog, eventStream });
        }));
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
            // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
            yield messageStore.clear();
            yield dataStore.clear();
            yield eventLog.clear();
        }));
        after(() => __awaiter(this, void 0, void 0, function* () {
            yield dwn.close();
        }));
        it('should support permission management through use of Request, Grants, and Revocations', () => __awaiter(this, void 0, void 0, function* () {
            // scenario:
            // 1. Verify anyone (Bob) can send a permission request to Alice
            // 2. Alice queries her DWN for new permission requests
            // 3. Verify a non-owner cannot create a grant for Bob in Alice's DWN
            // 4. Alice creates a permission grant for Bob in her DWN
            // 5. Verify that Bob can query the permission grant from Alice's DWN (even though Alice can also send it directly to Bob)
            // 6. Verify that any third-party can fetch revocation of the grant and find it is still active (not revoked)
            // 7. Verify that non-owner cannot revoke the grant
            // 8. Alice revokes the permission grant for Bob
            // 9. Verify that any third-party can fetch the revocation status of the permission grant
            var _a, _b, _c, _d, _e;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const bob = yield TestDataGenerator.generateDidKeyPersona();
            // 1. Verify anyone (Bob) can send a permission request to Alice
            const permissionScope = {
                interface: DwnInterfaceName.Records,
                method: DwnMethodName.Write,
                protocol: `any-protocol`
            };
            const requestToAlice = yield PermissionsProtocol.createRequest({
                signer: Jws.createSigner(bob),
                description: `Requesting to write to Alice's DWN`,
                delegated: false,
                scope: permissionScope
            });
            const requestWriteReply = yield dwn.processMessage(alice.did, requestToAlice.recordsWrite.message, { dataStream: DataStream.fromBytes(requestToAlice.permissionRequestBytes) });
            expect(requestWriteReply.status.code).to.equal(202);
            // 2. Alice queries her DWN for new permission requests
            const requestQuery = yield RecordsQuery.create({
                signer: Jws.createSigner(alice),
                filter: {
                    protocolPath: PermissionsProtocol.requestPath,
                    protocol: PermissionsProtocol.uri,
                    dateUpdated: { from: Time.createOffsetTimestamp({ seconds: -1 * 60 * 60 * 24 }) } // last 24 hours
                }
            });
            const requestQueryReply = yield dwn.processMessage(alice.did, requestQuery.message);
            const requestFromBob = (_a = requestQueryReply.entries) === null || _a === void 0 ? void 0 : _a[0];
            expect(requestQueryReply.status.code).to.equal(200);
            expect((_b = requestQueryReply.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(1);
            expect(requestFromBob.recordId).to.equal(requestToAlice.recordsWrite.message.recordId);
            // 3. Verify a non-owner cannot create a grant for Bob in Alice's DWN
            const decodedRequest = PermissionsProtocol.parseRequest(requestFromBob.encodedData);
            const unauthorizedGrantWrite = yield PermissionsProtocol.createGrant({
                signer: Jws.createSigner(bob),
                dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                description: 'Allow Bob to write',
                grantedTo: bob.did,
                scope: decodedRequest.scope
            });
            const unauthorizedGrantWriteReply = yield dwn.processMessage(alice.did, unauthorizedGrantWrite.recordsWrite.message, { dataStream: DataStream.fromBytes(unauthorizedGrantWrite.permissionGrantBytes) });
            expect(unauthorizedGrantWriteReply.status.code).to.equal(401);
            expect(unauthorizedGrantWriteReply.status.detail).to.contain(DwnErrorCode.ProtocolAuthorizationActionNotAllowed);
            // 4. Alice creates a permission grant for Bob in her DWN
            const grantWrite = yield PermissionsProtocol.createGrant({
                signer: Jws.createSigner(alice),
                dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                description: 'Allow Bob to write',
                grantedTo: bob.did,
                scope: decodedRequest.scope
            });
            const grantWriteReply = yield dwn.processMessage(alice.did, grantWrite.recordsWrite.message, { dataStream: DataStream.fromBytes(grantWrite.permissionGrantBytes) });
            expect(grantWriteReply.status.code).to.equal(202);
            // 5. Verify that Bob can query the permission grant from Alice's DWN (even though Alice can also send it directly to Bob)
            const grantQuery = yield RecordsQuery.create({
                signer: Jws.createSigner(bob),
                filter: {
                    protocolPath: PermissionsProtocol.grantPath,
                    protocol: PermissionsProtocol.uri,
                    dateUpdated: { from: Time.createOffsetTimestamp({ seconds: -1 * 60 * 60 * 24 }) } // last 24 hours
                }
            });
            const grantQueryReply = yield dwn.processMessage(alice.did, grantQuery.message);
            const grantFromBob = (_c = grantQueryReply.entries) === null || _c === void 0 ? void 0 : _c[0];
            expect(grantQueryReply.status.code).to.equal(200);
            expect((_d = grantQueryReply.entries) === null || _d === void 0 ? void 0 : _d.length).to.equal(1);
            expect(grantFromBob.recordId).to.equal(grantWrite.recordsWrite.message.recordId);
            // 6. Verify that any third-party can fetch revocation of the grant and find it is still active (not revoked)
            const revocationRead = yield RecordsRead.create({
                signer: Jws.createSigner(bob),
                filter: {
                    contextId: grantWrite.recordsWrite.message.contextId,
                    protocolPath: PermissionsProtocol.revocationPath
                }
            });
            const revocationReadReply = yield dwn.processMessage(alice.did, revocationRead.message);
            expect(revocationReadReply.status.code).to.equal(404);
            // 7. Verify that non-owner cannot revoke the grant
            const unauthorizedRevokeWrite = yield PermissionsProtocol.createRevocation({
                signer: Jws.createSigner(bob),
                grantId: grantWrite.recordsWrite.message.recordId,
                dateRevoked: Time.getCurrentTimestamp()
            });
            const unauthorizedRevokeWriteReply = yield dwn.processMessage(alice.did, unauthorizedRevokeWrite.recordsWrite.message, { dataStream: DataStream.fromBytes(unauthorizedRevokeWrite.permissionRevocationBytes) });
            expect(unauthorizedRevokeWriteReply.status.code).to.equal(401);
            expect(unauthorizedGrantWriteReply.status.detail).to.contain(DwnErrorCode.ProtocolAuthorizationActionNotAllowed);
            // 8. Alice revokes the permission grant for Bob
            const revokeWrite = yield PermissionsProtocol.createRevocation({
                signer: Jws.createSigner(alice),
                grantId: grantWrite.recordsWrite.message.recordId,
                dateRevoked: Time.getCurrentTimestamp()
            });
            const revokeWriteReply = yield dwn.processMessage(alice.did, revokeWrite.recordsWrite.message, { dataStream: DataStream.fromBytes(revokeWrite.permissionRevocationBytes) });
            expect(revokeWriteReply.status.code).to.equal(202);
            // 9. Verify that any third-party can fetch the revocation status of the permission grant
            const revocationReadReply2 = yield dwn.processMessage(alice.did, revocationRead.message);
            expect(revocationReadReply2.status.code).to.equal(200);
            expect((_e = revocationReadReply2.record) === null || _e === void 0 ? void 0 : _e.recordId).to.equal(revokeWrite.recordsWrite.message.recordId);
        }));
        describe('schema validation', () => {
            it('should reject with 400 if a permission message fails schema validation', () => __awaiter(this, void 0, void 0, function* () {
                // Scenario:
                // 1. Verify that a permission request is rejected with the data payload is invalid
                // 2. Verify that a permission grant is rejected with the data payload is invalid
                // 3. Write a valid permission grant
                // 4. Verify that a permission revocation is rejected with the data payload is invalid
                // 5. Verify that an unexpected/unknown permission record is rejected
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                // 1. Verify that a permission request is rejected with the data payload is invalid
                const invalidPermissionRequestData = {
                    description: 'missing required properties such as `scope`'
                };
                const requestBytes = Encoder.objectToBytes(invalidPermissionRequestData);
                const requestRecordsWrite = yield RecordsWrite.create({
                    signer: Jws.createSigner(bob),
                    protocol: PermissionsProtocol.uri,
                    protocolPath: PermissionsProtocol.requestPath,
                    dataFormat: 'application/json',
                    data: requestBytes,
                });
                const requestWriteReply = yield dwn.processMessage(alice.did, requestRecordsWrite.message, { dataStream: DataStream.fromBytes(requestBytes) });
                expect(requestWriteReply.status.code).to.equal(400);
                expect(requestWriteReply.status.detail).to.contain(DwnErrorCode.SchemaValidatorFailure);
                // 2. Verify that a permission grant is rejected with the data payload is invalid
                const invalidPermissionGrantData = {
                    description: 'missing required properties such as `scope`'
                };
                const grantBytes = Encoder.objectToBytes(invalidPermissionGrantData);
                const grantRecordsWrite = yield RecordsWrite.create({
                    signer: Jws.createSigner(alice),
                    recipient: bob.did,
                    protocol: PermissionsProtocol.uri,
                    protocolPath: PermissionsProtocol.grantPath,
                    dataFormat: 'application/json',
                    data: grantBytes,
                });
                const invalidGrantWriteReply = yield dwn.processMessage(alice.did, grantRecordsWrite.message, { dataStream: DataStream.fromBytes(grantBytes) });
                expect(invalidGrantWriteReply.status.code).to.equal(400);
                expect(invalidGrantWriteReply.status.detail).to.contain(DwnErrorCode.SchemaValidatorFailure);
                // 3. Write a valid permission grant
                const grantWrite = yield PermissionsProtocol.createGrant({
                    signer: Jws.createSigner(alice),
                    dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                    description: 'Allow Bob to write',
                    grantedTo: bob.did,
                    scope: { interface: DwnInterfaceName.Records, method: DwnMethodName.Write }
                });
                const grantWriteReply = yield dwn.processMessage(alice.did, grantWrite.recordsWrite.message, { dataStream: DataStream.fromBytes(grantWrite.permissionGrantBytes) });
                expect(grantWriteReply.status.code).to.equal(202);
                // 4. Verify that a permission revocation is rejected with the data payload is invalid
                const invalidPermissionRevocationData = {
                    unknownProperty: 'unknown property',
                };
                const revocationBytes = Encoder.objectToBytes(invalidPermissionRevocationData);
                const revocationRecordsWrite = yield RecordsWrite.create({
                    signer: Jws.createSigner(alice),
                    parentContextId: grantWrite.recordsWrite.message.recordId,
                    protocol: PermissionsProtocol.uri,
                    protocolPath: PermissionsProtocol.revocationPath,
                    dataFormat: 'application/json',
                    data: revocationBytes,
                });
                const revokeWriteReply = yield dwn.processMessage(alice.did, revocationRecordsWrite.message, { dataStream: DataStream.fromBytes(revocationBytes) });
                expect(revokeWriteReply.status.code).to.equal(400);
                expect(revokeWriteReply.status.detail).to.contain(DwnErrorCode.SchemaValidatorAdditionalPropertyNotAllowed);
                // 5. Verify that an unexpected/unknown permission record is rejected
                const unknownPermissionRecordData = {
                    unknownProperty: 'unknown property',
                };
                const unknownRecordBytes = Encoder.objectToBytes(unknownPermissionRecordData);
                const unknownRecordsWrite = yield RecordsWrite.create({
                    signer: Jws.createSigner(alice),
                    protocol: PermissionsProtocol.uri,
                    protocolPath: 'unknown-path',
                    dataFormat: 'application/json',
                    data: revocationBytes,
                });
                expect(() => PermissionsProtocol.validateSchema(unknownRecordsWrite.message, unknownRecordBytes))
                    .to.throw(DwnErrorCode.PermissionsProtocolValidateSchemaUnexpectedRecord);
            }));
            it('ensures that `schema` and protocol related fields `protocol`, `contextId` or `protocolPath` are not both present', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                // `schema` and `protocol` may not both be present in grant `scope`
                const schemaAndProtocolGrant = yield PermissionsProtocol.createGrant({
                    signer: Jws.createSigner(alice),
                    dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                    description: 'Allow Bob to write',
                    grantedTo: bob.did,
                    scope: {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                        schema: 'some-schema',
                        protocol: 'some-protocol'
                    }
                });
                const schemaAndProtocolGrantReply = yield dwn.processMessage(alice.did, schemaAndProtocolGrant.recordsWrite.message, { dataStream: DataStream.fromBytes(schemaAndProtocolGrant.permissionGrantBytes) });
                expect(schemaAndProtocolGrantReply.status.code).to.eq(400);
                expect(schemaAndProtocolGrantReply.status.detail).to.contain(DwnErrorCode.PermissionsProtocolValidateScopeSchemaProhibitedProperties);
                // `schema` and `contextId` may not both be present in grant `scope`
                const schemaAndContextIdGrant = yield PermissionsProtocol.createGrant({
                    signer: Jws.createSigner(alice),
                    dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                    description: 'Allow Bob to write',
                    grantedTo: bob.did,
                    scope: {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                        schema: 'some-schema',
                        contextId: 'some-context-id'
                    }
                });
                const schemaAndContextIdGrantReply = yield dwn.processMessage(alice.did, schemaAndContextIdGrant.recordsWrite.message, { dataStream: DataStream.fromBytes(schemaAndContextIdGrant.permissionGrantBytes) });
                expect(schemaAndContextIdGrantReply.status.code).to.eq(400);
                expect(schemaAndContextIdGrantReply.status.detail).to.contain(DwnErrorCode.PermissionsProtocolValidateScopeSchemaProhibitedProperties);
                // `schema` and `protocolPath` may not both be present in grant `scope`
                const schemaAndProtocolPathGrant = yield PermissionsProtocol.createGrant({
                    signer: Jws.createSigner(alice),
                    dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                    description: 'Allow Bob to write',
                    grantedTo: bob.did,
                    scope: {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                        schema: 'some-schema',
                        protocolPath: 'some-protocol-path'
                    }
                });
                const schemaAndProtocolPathGrantReply = yield dwn.processMessage(alice.did, schemaAndProtocolPathGrant.recordsWrite.message, { dataStream: DataStream.fromBytes(schemaAndProtocolPathGrant.permissionGrantBytes) });
                expect(schemaAndProtocolPathGrantReply.status.code).to.eq(400);
                expect(schemaAndProtocolPathGrantReply.status.detail).to.contain(DwnErrorCode.PermissionsProtocolValidateScopeSchemaProhibitedProperties);
            }));
            it('ensures that `contextId` and `protocolPath` are not both present in grant scope', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                const grant = yield PermissionsProtocol.createGrant({
                    signer: Jws.createSigner(alice),
                    dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                    description: 'Allow Bob to write',
                    grantedTo: bob.did,
                    scope: {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                        protocol: 'some-protocol',
                        contextId: 'some-context-id',
                        protocolPath: 'some-protocol-path'
                    }
                });
                const schemaAndProtocolGrantReply = yield dwn.processMessage(alice.did, grant.recordsWrite.message, { dataStream: DataStream.fromBytes(grant.permissionGrantBytes) });
                expect(schemaAndProtocolGrantReply.status.code).to.eq(400);
                expect(schemaAndProtocolGrantReply.status.detail).to.contain(DwnErrorCode.PermissionsProtocolValidateScopeContextIdProhibitedProperties);
            }));
        });
    }));
}
//# sourceMappingURL=permissions.spec.js.map