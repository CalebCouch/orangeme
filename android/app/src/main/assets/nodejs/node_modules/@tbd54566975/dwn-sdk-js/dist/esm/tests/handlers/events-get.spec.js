var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Dwn } from '../../src/index.js';
import { EventsGetHandler } from '../../src/handlers/events-get.js';
import { expect } from 'chai';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { Message } from '../../src/core/message.js';
import { TestEventStream } from '../test-event-stream.js';
import { TestStores } from '../test-stores.js';
import { DidKey, UniversalResolver } from '@web5/dids';
export function testEventsGetHandler() {
    describe('EventsGetHandler.handle()', () => {
        let didResolver;
        let messageStore;
        let dataStore;
        let eventLog;
        let eventStream;
        let dwn;
        // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
        // so that different test suites can reuse the same backend store for testing
        before(() => __awaiter(this, void 0, void 0, function* () {
            didResolver = new UniversalResolver({ didResolvers: [DidKey] });
            const stores = TestStores.get();
            messageStore = stores.messageStore;
            dataStore = stores.dataStore;
            eventLog = stores.eventLog;
            eventStream = TestEventStream.get();
            dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog, eventStream });
        }));
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
            yield messageStore.clear();
            yield dataStore.clear();
            yield eventLog.clear();
        }));
        after(() => __awaiter(this, void 0, void 0, function* () {
            yield dwn.close();
        }));
        it('returns a 401 if tenant is not author', () => __awaiter(this, void 0, void 0, function* () {
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const bob = yield TestDataGenerator.generateDidKeyPersona();
            const { message } = yield TestDataGenerator.generateEventsGet({ author: alice });
            const eventsGetHandler = new EventsGetHandler(didResolver, eventLog);
            const reply = yield eventsGetHandler.handle({ tenant: bob.did, message });
            expect(reply.status.code).to.equal(401);
            expect(reply.entries).to.not.exist;
        }));
        it('returns a 400 if message is invalid', () => __awaiter(this, void 0, void 0, function* () {
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const { message } = yield TestDataGenerator.generateEventsGet({ author: alice });
            message['descriptor']['troll'] = 'hehe';
            const eventsGetHandler = new EventsGetHandler(didResolver, eventLog);
            const reply = yield eventsGetHandler.handle({ tenant: alice.did, message });
            expect(reply.status.code).to.equal(400);
            expect(reply.entries).to.not.exist;
        }));
        it('returns all events for a tenant if cursor is not provided', () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const expectedCids = [];
            for (let i = 0; i < 5; i += 1) {
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const reply = yield dwn.processMessage(alice.did, message, { dataStream });
                expect(reply.status.code).to.equal(202);
                const messageCid = yield Message.getCid(message);
                expectedCids.push(messageCid);
            }
            const { message } = yield TestDataGenerator.generateEventsGet({ author: alice });
            const reply = yield dwn.processMessage(alice.did, message);
            expect(reply.status.code).to.equal(200);
            expect(reply.data).to.not.exist;
            expect((_a = reply.entries) === null || _a === void 0 ? void 0 : _a.length).to.equal(expectedCids.length);
            for (let i = 0; i < reply.entries.length; i += 1) {
                expect(reply.entries[i]).to.equal(expectedCids[i]);
            }
        }));
        it('returns all events after cursor if provided', () => __awaiter(this, void 0, void 0, function* () {
            var _b;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            for (let i = 0; i < 5; i += 1) {
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const reply = yield dwn.processMessage(alice.did, message, { dataStream });
                expect(reply.status.code).to.equal(202);
            }
            const { message } = yield TestDataGenerator.generateEventsGet({ author: alice });
            let reply = yield dwn.processMessage(alice.did, message);
            expect(reply.status.code).to.equal(200);
            expect((_b = reply.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(5);
            expect(reply.cursor).to.not.be.undefined;
            const expectedCids = [];
            for (let i = 0; i < 3; i += 1) {
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const reply = yield dwn.processMessage(alice.did, message, { dataStream });
                expect(reply.status.code).to.equal(202);
                const messageCid = yield Message.getCid(message);
                expectedCids.push(messageCid);
            }
            const { message: m } = yield TestDataGenerator.generateEventsGet({ author: alice, cursor: reply.cursor });
            reply = yield dwn.processMessage(alice.did, m);
            expect(reply.status.code).to.equal(200);
            expect(reply.data).to.not.exist;
            expect(reply.entries.length).to.equal(expectedCids.length);
            for (let i = 0; i < reply.entries.length; i += 1) {
                expect(reply.entries[i]).to.equal(expectedCids[i]);
            }
        }));
    });
}
//# sourceMappingURL=events-get.spec.js.map