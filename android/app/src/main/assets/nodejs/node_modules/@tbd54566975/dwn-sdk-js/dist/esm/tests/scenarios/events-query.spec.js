var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import freeForAll from '../vectors/protocol-definitions/free-for-all.json' assert { type: 'json' };
import threadProtocol from '../vectors/protocol-definitions/thread-role.json' assert { type: 'json' };
import { expect } from 'chai';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestEventStream } from '../test-event-stream.js';
import { TestStores } from '../test-stores.js';
import { DidKey, UniversalResolver } from '@web5/dids';
import { Dwn, DwnConstant, DwnInterfaceName, DwnMethodName, Message, Time } from '../../src/index.js';
export function testEventsQueryScenarios() {
    describe('events query tests', () => {
        let didResolver;
        let messageStore;
        let dataStore;
        let eventLog;
        let eventStream;
        let dwn;
        // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
        // so that different test suites can reuse the same backend store for testing
        before(() => __awaiter(this, void 0, void 0, function* () {
            didResolver = new UniversalResolver({ didResolvers: [DidKey] });
            const stores = TestStores.get();
            messageStore = stores.messageStore;
            dataStore = stores.dataStore;
            eventLog = stores.eventLog;
            eventStream = TestEventStream.get();
            dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog, eventStream });
        }));
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
            yield messageStore.clear();
            yield dataStore.clear();
            yield eventLog.clear();
        }));
        after(() => __awaiter(this, void 0, void 0, function* () {
            yield dwn.close();
        }));
        it('supports multiple filter types', () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const record = yield TestDataGenerator.generateRecordsWrite({ author: alice });
            const protocol = yield TestDataGenerator.generateProtocolsConfigure({ author: alice });
            // insert data
            const recordReply = yield dwn.processMessage(alice.did, record.message, { dataStream: record.dataStream });
            const protocolReply = yield dwn.processMessage(alice.did, protocol.message);
            expect(recordReply.status.code).to.equal(202, 'RecordsWrite');
            expect(protocolReply.status.code).to.equal(202, 'ProtocolConfigure');
            const eventsQueryRecords = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [
                    { recordId: record.message.recordId },
                    { protocol: protocol.message.descriptor.definition.protocol } // ProtocolConfigure
                ],
            });
            const recordEventsReply = yield dwn.processMessage(alice.did, eventsQueryRecords.message);
            expect(recordEventsReply.status.code).to.equal(200);
            expect((_a = recordEventsReply.entries) === null || _a === void 0 ? void 0 : _a.length).to.equal(2);
            expect(recordEventsReply.entries).to.have.members([
                yield Message.getCid(record.message),
                yield Message.getCid(protocol.message),
            ]);
        }));
        it('filters by interface type', () => __awaiter(this, void 0, void 0, function* () {
            // scenario:
            // alice creates 2 different types of messages (RecordsWrite, ProtocolsConfigure)
            // alice queries for messages from each interface respectively (Records, Protocols)
            // alice creates 2 additional messages (RecordsDelete, ProtocolsRevoke)
            // alice queries for messages for each interface respectively providing a cursor.
            var _b, _c, _d, _e;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const record = yield TestDataGenerator.generateRecordsWrite({ author: alice });
            const protocol = yield TestDataGenerator.generateProtocolsConfigure({ author: alice });
            // insert data
            const recordReply = yield dwn.processMessage(alice.did, record.message, { dataStream: record.dataStream });
            const protocolReply = yield dwn.processMessage(alice.did, protocol.message);
            expect(recordReply.status.code).to.equal(202, 'RecordsWrite');
            expect(protocolReply.status.code).to.equal(202, 'ProtocolConfigure');
            let eventsQueryRecords = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ interface: DwnInterfaceName.Records }],
            });
            const recordEventsReply = yield dwn.processMessage(alice.did, eventsQueryRecords.message);
            expect(recordEventsReply.status.code).to.equal(200);
            expect((_b = recordEventsReply.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(1);
            expect(recordEventsReply.entries[0]).to.equal(yield Message.getCid(record.message));
            let eventsQueryProtocols = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ interface: DwnInterfaceName.Protocols }],
            });
            const protocolEventsReply = yield dwn.processMessage(alice.did, eventsQueryProtocols.message);
            expect(protocolEventsReply.status.code).to.equal(200);
            expect((_c = protocolEventsReply.entries) === null || _c === void 0 ? void 0 : _c.length).to.equal(1);
            expect(protocolEventsReply.entries[0]).to.equal(yield Message.getCid(protocol.message));
            // insert additional data to query beyond a cursor
            const recordDelete = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: record.message.recordId });
            const recordDeleteReply = yield dwn.processMessage(alice.did, recordDelete.message);
            expect(recordDeleteReply.status.code).to.equal(202, 'RecordsDelete');
            // query after cursor
            eventsQueryRecords = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ interface: DwnInterfaceName.Records }],
                cursor: recordEventsReply.cursor, // the cursor from the prior query
            });
            const recordEventsReplyAfterCursor = yield dwn.processMessage(alice.did, eventsQueryRecords.message);
            expect(recordEventsReplyAfterCursor.status.code).to.equal(200);
            expect((_d = recordEventsReplyAfterCursor.entries) === null || _d === void 0 ? void 0 : _d.length).to.equal(1);
            expect(recordEventsReplyAfterCursor.entries[0]).to.equal(yield Message.getCid(recordDelete.message));
            eventsQueryProtocols = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ interface: DwnInterfaceName.Protocols }],
                cursor: protocolEventsReply.cursor, // the cursor from the prior query
            });
            const protocolEventsReplyAfterCursor = yield dwn.processMessage(alice.did, eventsQueryProtocols.message);
            expect(protocolEventsReplyAfterCursor.status.code).to.equal(200);
            expect((_e = protocolEventsReplyAfterCursor.entries) === null || _e === void 0 ? void 0 : _e.length).to.equal(0); // no new messages
        }));
        it('filters by method type', () => __awaiter(this, void 0, void 0, function* () {
            // scenario:
            // alice creates a variety of Messages (RecordsWrite, RecordsDelete, ProtocolConfigure)
            // alice queries for only RecordsWrite messages
            // alice creates more messages to query beyond a cursor
            var _f, _g;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            // write 1
            const record1 = yield TestDataGenerator.generateRecordsWrite({ author: alice });
            const record1Reply = yield dwn.processMessage(alice.did, record1.message, { dataStream: record1.dataStream });
            expect(record1Reply.status.code).to.equal(202, 'RecordsWrite');
            // other messages
            const protocol = yield TestDataGenerator.generateProtocolsConfigure({ author: alice });
            const protocolReply = yield dwn.processMessage(alice.did, protocol.message);
            expect(protocolReply.status.code).to.equal(202, 'ProtocolConfigure');
            // write 2
            const record2 = yield TestDataGenerator.generateRecordsWrite({ author: alice });
            const record2Reply = yield dwn.processMessage(alice.did, record2.message, { dataStream: record2.dataStream });
            expect(record2Reply.status.code).to.equal(202, 'RecordsWrite');
            // delete write 1
            const delete1 = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: record1.message.recordId });
            const delete1Reply = yield dwn.processMessage(alice.did, delete1.message);
            expect(delete1Reply.status.code).to.equal(202, 'RecordsDelete');
            let recordsWriteEvents = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ interface: DwnInterfaceName.Records, method: DwnMethodName.Write }]
            });
            const recordsWriteEventsReply = yield dwn.processMessage(alice.did, recordsWriteEvents.message);
            expect(recordsWriteEventsReply.status.code).to.equal(200);
            expect((_f = recordsWriteEventsReply.entries) === null || _f === void 0 ? void 0 : _f.length).to.equal(2);
            expect(recordsWriteEventsReply.entries[0]).to.equal(yield Message.getCid(record1.message));
            expect(recordsWriteEventsReply.entries[1]).to.equal(yield Message.getCid(record2.message));
            // additional messages
            const record2Update = yield TestDataGenerator.generateFromRecordsWrite({ author: alice, existingWrite: record2.recordsWrite });
            const record2UpdateReply = yield dwn.processMessage(alice.did, record2Update.message, { dataStream: record2Update.dataStream });
            expect(record2UpdateReply.status.code).to.equal(202, 'RecordsDelete');
            recordsWriteEvents = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ interface: DwnInterfaceName.Records, method: DwnMethodName.Write }],
                cursor: recordsWriteEventsReply.cursor,
            });
            const recordsWriteEventsReplyAfterCursor = yield dwn.processMessage(alice.did, recordsWriteEvents.message);
            expect(recordsWriteEventsReplyAfterCursor.status.code).to.equal(200);
            expect((_g = recordsWriteEventsReplyAfterCursor.entries) === null || _g === void 0 ? void 0 : _g.length).to.equal(1);
            expect(recordsWriteEventsReplyAfterCursor.entries[0]).to.equal(yield Message.getCid(record2Update.message));
        }));
        it('filters by a dateUpdated (messageTimestamp) range across different message types', () => __awaiter(this, void 0, void 0, function* () {
            var _h, _j;
            // scenario:
            // alice creates (2) messages, (RecordsWrite and ProtocolsConfigure)
            // each message on the first date of the year (2021, 2022 and 2023 respectively.
            // alice queries for all records beyond the last day of 2021 and should return 1 of the 2 messages (ProtocolConfigure)
            // alice then creates a RecordsDelete message for the original RecordsWrite
            // alice queries once again however supplying a cursor of the last message from the prior query, returning the RecordsDelete message.
            const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
            const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2021, messageTimestamp: firstDayOf2021 });
            const protocol = yield TestDataGenerator.generateProtocolsConfigure({ author: alice, messageTimestamp: firstDayOf2023 });
            // insert data
            const writeReply = yield dwn.processMessage(alice.did, write.message, { dataStream: write.dataStream });
            const protocolReply = yield dwn.processMessage(alice.did, protocol.message);
            expect(writeReply.status.code).to.equal(202, 'RecordsWrite');
            expect(protocolReply.status.code).to.equal(202, 'ProtocolConfigure');
            // query from last day of 2021
            const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
            let eventsQuery1 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateUpdated: { from: lastDayOf2021 } }],
            });
            let reply1 = yield dwn.processMessage(alice.did, eventsQuery1.message);
            expect(reply1.status.code).to.equal(200);
            expect((_h = reply1.entries) === null || _h === void 0 ? void 0 : _h.length).to.equal(1);
            expect(reply1.entries[0]).to.equal(yield Message.getCid(protocol.message));
            // delete the RecordsWrite
            const delete1 = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: write.message.recordId });
            const delete1Reply = yield dwn.processMessage(alice.did, delete1.message);
            expect(delete1Reply.status.code).to.equal(202);
            eventsQuery1 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateUpdated: { from: lastDayOf2021 } }],
                cursor: reply1.cursor
            });
            reply1 = yield dwn.processMessage(alice.did, eventsQuery1.message);
            expect(reply1.status.code).to.equal(200);
            expect((_j = reply1.entries) === null || _j === void 0 ? void 0 : _j.length).to.equal(1);
            expect(reply1.entries[0]).to.equal(yield Message.getCid(delete1.message));
        }));
        it('filters by dateCreated', () => __awaiter(this, void 0, void 0, function* () {
            var _k, _l, _m, _o, _p, _q, _r, _s;
            // scenario: 4 records, created on first of 2021, 2022, 2023, 2024 respectively, only the first 2 records
            const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
            const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
            const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
            const firstDayOf2024 = Time.createTimestamp({ year: 2024, month: 1, day: 1 });
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2021, messageTimestamp: firstDayOf2021 });
            const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2022, messageTimestamp: firstDayOf2022 });
            const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2023, messageTimestamp: firstDayOf2023 });
            const write4 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2024, messageTimestamp: firstDayOf2024 });
            // insert data
            const writeReply1 = yield dwn.processMessage(alice.did, write1.message, { dataStream: write1.dataStream });
            const writeReply2 = yield dwn.processMessage(alice.did, write2.message, { dataStream: write2.dataStream });
            const writeReply3 = yield dwn.processMessage(alice.did, write3.message, { dataStream: write3.dataStream });
            const writeReply4 = yield dwn.processMessage(alice.did, write4.message, { dataStream: write4.dataStream });
            expect(writeReply1.status.code).to.equal(202);
            expect(writeReply2.status.code).to.equal(202);
            expect(writeReply3.status.code).to.equal(202);
            expect(writeReply4.status.code).to.equal(202);
            // testing `from` range with a limit
            const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
            let fromLastDayOf2021 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateCreated: { from: lastDayOf2021 } }],
            });
            let fromLastDayOf2021Reply = yield dwn.processMessage(alice.did, fromLastDayOf2021.message);
            expect(fromLastDayOf2021Reply.status.code).to.equal(200);
            expect((_k = fromLastDayOf2021Reply.entries) === null || _k === void 0 ? void 0 : _k.length).to.equal(3);
            expect(fromLastDayOf2021Reply.entries[0]).to.equal(yield Message.getCid(write2.message));
            expect(fromLastDayOf2021Reply.entries[1]).to.equal(yield Message.getCid(write3.message));
            expect(fromLastDayOf2021Reply.entries[2]).to.equal(yield Message.getCid(write4.message));
            // testing `to` range
            const lastDayOf2022 = Time.createTimestamp({ year: 2022, month: 12, day: 31 });
            let toLastDayOf2022 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateCreated: { to: lastDayOf2022 } }],
            });
            let toLastDayOf2022Reply = yield dwn.processMessage(alice.did, toLastDayOf2022.message);
            expect(toLastDayOf2022Reply.status.code).to.equal(200);
            expect((_l = toLastDayOf2022Reply.entries) === null || _l === void 0 ? void 0 : _l.length).to.equal(2);
            expect(toLastDayOf2022Reply.entries[0]).to.equal(yield Message.getCid(write1.message));
            expect(toLastDayOf2022Reply.entries[1]).to.equal(yield Message.getCid(write2.message));
            // testing `from` and `to` range
            const lastDayOf2023 = Time.createTimestamp({ year: 2023, month: 12, day: 31 });
            let fromLastDay2022ToLastDay2023 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateCreated: { from: lastDayOf2022, to: lastDayOf2023 } }],
            });
            let fromLastDayOf2022ToLastDay2023Reply = yield dwn.processMessage(alice.did, fromLastDay2022ToLastDay2023.message);
            expect(fromLastDayOf2022ToLastDay2023Reply.status.code).to.equal(200);
            expect((_m = fromLastDayOf2022ToLastDay2023Reply.entries) === null || _m === void 0 ? void 0 : _m.length).to.equal(1);
            expect(fromLastDayOf2022ToLastDay2023Reply.entries[0]).to.equal(yield Message.getCid(write3.message));
            // testing edge case where value equals `from` and `to`
            let fromFirstDay2022ToFirstDay2023 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateCreated: { from: firstDayOf2022, to: firstDayOf2023 } }],
            });
            let fromFirstDay2022ToFirstDay2023Reply = yield dwn.processMessage(alice.did, fromFirstDay2022ToFirstDay2023.message);
            expect(fromFirstDay2022ToFirstDay2023Reply.status.code).to.equal(200);
            expect((_o = fromFirstDay2022ToFirstDay2023Reply.entries) === null || _o === void 0 ? void 0 : _o.length).to.equal(1);
            expect(fromFirstDay2022ToFirstDay2023Reply.entries[0]).to.equal(yield Message.getCid(write2.message));
            // add an additional records to match against the previous queries
            const write5 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: lastDayOf2022, messageTimestamp: lastDayOf2022 });
            const writeReply5 = yield dwn.processMessage(alice.did, write5.message, { dataStream: write5.dataStream });
            expect(writeReply5.status.code).to.equal(202);
            const write6 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2021, messageTimestamp: firstDayOf2021 });
            const writeReply6 = yield dwn.processMessage(alice.did, write6.message, { dataStream: write6.dataStream });
            expect(writeReply6.status.code).to.equal(202);
            fromLastDayOf2021 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateCreated: { from: lastDayOf2021 } }],
                cursor: fromLastDayOf2021Reply.cursor
            });
            fromLastDayOf2021Reply = yield dwn.processMessage(alice.did, fromLastDayOf2021.message);
            expect(fromLastDayOf2021Reply.status.code).to.equal(200);
            expect((_p = fromLastDayOf2021Reply.entries) === null || _p === void 0 ? void 0 : _p.length).to.equal(1);
            expect(fromLastDayOf2021Reply.entries[0]).to.equal(yield Message.getCid(write5.message));
            toLastDayOf2022 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateCreated: { to: lastDayOf2022 } }],
                cursor: toLastDayOf2022Reply.cursor,
            });
            toLastDayOf2022Reply = yield dwn.processMessage(alice.did, toLastDayOf2022.message);
            expect(toLastDayOf2022Reply.status.code).to.equal(200);
            expect((_q = toLastDayOf2022Reply.entries) === null || _q === void 0 ? void 0 : _q.length).to.equal(1);
            expect(toLastDayOf2022Reply.entries[0]).to.equal(yield Message.getCid(write6.message));
            fromLastDay2022ToLastDay2023 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateCreated: { from: lastDayOf2022, to: lastDayOf2023 } }],
                cursor: fromLastDayOf2022ToLastDay2023Reply.cursor,
            });
            fromLastDayOf2022ToLastDay2023Reply = yield dwn.processMessage(alice.did, fromLastDay2022ToLastDay2023.message);
            expect(fromLastDayOf2022ToLastDay2023Reply.status.code).to.equal(200);
            expect((_r = fromLastDayOf2022ToLastDay2023Reply.entries) === null || _r === void 0 ? void 0 : _r.length).to.equal(1);
            expect(fromLastDayOf2021Reply.entries[0]).to.equal(yield Message.getCid(write5.message));
            // testing edge case where value equals `from` and `to`
            fromFirstDay2022ToFirstDay2023 = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ dateCreated: { from: firstDayOf2022, to: firstDayOf2023 } }],
                cursor: fromFirstDay2022ToFirstDay2023Reply.cursor,
            });
            fromFirstDay2022ToFirstDay2023Reply = yield dwn.processMessage(alice.did, fromFirstDay2022ToFirstDay2023.message);
            expect(fromFirstDay2022ToFirstDay2023Reply.status.code).to.equal(200);
            expect((_s = fromFirstDay2022ToFirstDay2023Reply.entries) === null || _s === void 0 ? void 0 : _s.length).to.equal(1);
            expect(fromLastDayOf2021Reply.entries[0]).to.equal(yield Message.getCid(write5.message));
        }));
        it('filters by a protocol across different message types', () => __awaiter(this, void 0, void 0, function* () {
            // scenario:
            //    alice creates (3) different message types all related to "proto1" (Configure, RecordsWrite, RecordsDelete)
            //    alice creates (3) different message types all related to "proto2" (Configure, RecordsWrite, RecordsDelete)
            //    when issuing an EventsQuery for the specific protocol, only Events related to it should be returned.
            //    alice then creates an additional messages to query after a cursor
            var _t, _u, _v, _w;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            // create a proto1
            const protoConf1 = yield TestDataGenerator.generateProtocolsConfigure({
                author: alice,
                protocolDefinition: Object.assign(Object.assign({}, freeForAll), { protocol: 'proto1' })
            });
            const postProperties = {
                protocolPath: 'post',
                schema: freeForAll.types.post.schema,
                dataFormat: freeForAll.types.post.dataFormats[0],
            };
            const proto1 = protoConf1.message.descriptor.definition.protocol;
            const protoConf1Response = yield dwn.processMessage(alice.did, protoConf1.message);
            expect(protoConf1Response.status.code).equals(202);
            // create a proto2
            const protoConf2 = yield TestDataGenerator.generateProtocolsConfigure({
                author: alice,
                protocolDefinition: Object.assign(Object.assign({}, freeForAll), { protocol: 'proto2' })
            });
            const proto2 = protoConf2.message.descriptor.definition.protocol;
            const protoConf2Response = yield dwn.processMessage(alice.did, protoConf2.message);
            expect(protoConf2Response.status.code).equals(202);
            // create a record for proto1
            const write1proto1 = yield TestDataGenerator.generateRecordsWrite(Object.assign({ author: alice, protocol: proto1 }, postProperties));
            const write1Response = yield dwn.processMessage(alice.did, write1proto1.message, { dataStream: write1proto1.dataStream });
            expect(write1Response.status.code).equals(202);
            // create a record for proto2
            const write1proto2 = yield TestDataGenerator.generateRecordsWrite(Object.assign({ author: alice, protocol: proto2 }, postProperties));
            const write1Proto2Response = yield dwn.processMessage(alice.did, write1proto2.message, { dataStream: write1proto2.dataStream });
            expect(write1Proto2Response.status.code).equals(202);
            // filter for proto1
            let proto1EventsQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ protocol: proto1 }]
            });
            let proto1EventsReply = yield dwn.processMessage(alice.did, proto1EventsQuery.message);
            expect(proto1EventsReply.status.code).equals(200);
            expect((_t = proto1EventsReply.entries) === null || _t === void 0 ? void 0 : _t.length).equals(2);
            // check order of events returned.
            expect(proto1EventsReply.entries[0]).to.equal(yield Message.getCid(protoConf1.message));
            expect(proto1EventsReply.entries[1]).to.equal(yield Message.getCid(write1proto1.message));
            // filter for proto2
            let proto2EventsQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ protocol: proto2 }]
            });
            let proto2EventsReply = yield dwn.processMessage(alice.did, proto2EventsQuery.message);
            expect(proto2EventsReply.status.code).equals(200);
            expect((_u = proto2EventsReply.entries) === null || _u === void 0 ? void 0 : _u.length).equals(2);
            // check order of events returned.
            expect(proto2EventsReply.entries[0]).to.equal(yield Message.getCid(protoConf2.message));
            expect(proto2EventsReply.entries[1]).to.equal(yield Message.getCid(write1proto2.message));
            // delete proto1 message
            const deleteProto1Message = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: write1proto1.message.recordId });
            const deleteProto1MessageReply = yield dwn.processMessage(alice.did, deleteProto1Message.message);
            expect(deleteProto1MessageReply.status.code).to.equal(202);
            // delete proto2 message
            const deleteProto2Message = yield TestDataGenerator.generateRecordsDelete({ author: alice, recordId: write1proto2.message.recordId });
            const deleteProto2MessageReply = yield dwn.processMessage(alice.did, deleteProto2Message.message);
            expect(deleteProto2MessageReply.status.code).to.equal(202);
            //query messages beyond the cursor
            proto1EventsQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ protocol: proto1 }],
                cursor: proto1EventsReply.cursor,
            });
            proto1EventsReply = yield dwn.processMessage(alice.did, proto1EventsQuery.message);
            expect(proto1EventsReply.status.code).equals(200);
            expect((_v = proto1EventsReply.entries) === null || _v === void 0 ? void 0 : _v.length).equals(1);
            expect(proto1EventsReply.entries[0]).to.equal(yield Message.getCid(deleteProto1Message.message));
            //query messages beyond the cursor
            proto2EventsQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ protocol: proto2 }],
                cursor: proto2EventsReply.cursor,
            });
            proto2EventsReply = yield dwn.processMessage(alice.did, proto2EventsQuery.message);
            expect(proto2EventsReply.status.code).equals(200);
            expect((_w = proto2EventsReply.entries) === null || _w === void 0 ? void 0 : _w.length).equals(1);
            expect(proto2EventsReply.entries[0]).to.equal(yield Message.getCid(deleteProto2Message.message));
        }));
        it('filters by protocol, protocolPath & parentId', () => __awaiter(this, void 0, void 0, function* () {
            // scenario: get all messages across a protocol & protocolPath combo
            //    alice installs a protocol and creates a thread
            //    alice adds bob and carol as participants
            //    alice, bob, and carol all create messages
            //    alice filter for 'thread', 'thread/participants' and 'thread/messages'
            //    alice deletes carol participant message
            //    alice filters for 'thread/participant' after a cursor
            var _x, _y, _z, _0, _1;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const bob = yield TestDataGenerator.generateDidKeyPersona();
            const carol = yield TestDataGenerator.generateDidKeyPersona();
            // create protocol
            const protocolConfigure = yield TestDataGenerator.generateProtocolsConfigure({
                author: alice,
                protocolDefinition: Object.assign({}, threadProtocol)
            });
            const protocolConfigureReply = yield dwn.processMessage(alice.did, protocolConfigure.message);
            expect(protocolConfigureReply.status.code).to.equal(202);
            const protocol = protocolConfigure.message.descriptor.definition.protocol;
            // alice creates thread
            const thread = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                protocol: protocol,
                protocolPath: 'thread'
            });
            const threadReply = yield dwn.processMessage(alice.did, thread.message, { dataStream: thread.dataStream });
            expect(threadReply.status.code).to.equal(202);
            // add bob as participant
            const bobParticipant = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                recipient: bob.did,
                parentContextId: thread.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/participant'
            });
            const bobParticipantReply = yield dwn.processMessage(alice.did, bobParticipant.message, { dataStream: bobParticipant.dataStream });
            expect(bobParticipantReply.status.code).to.equal(202);
            // add carol as participant
            const carolParticipant = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                recipient: carol.did,
                parentContextId: thread.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/participant'
            });
            const carolParticipantReply = yield dwn.processMessage(alice.did, carolParticipant.message, { dataStream: carolParticipant.dataStream });
            expect(carolParticipantReply.status.code).to.equal(202);
            // add a message to protocol1
            const message1 = yield TestDataGenerator.generateRecordsWrite({
                author: bob,
                recipient: alice.did,
                parentContextId: thread.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/chat',
                protocolRole: 'thread/participant',
            });
            const message1Reply = yield dwn.processMessage(alice.did, message1.message, { dataStream: message1.dataStream });
            expect(message1Reply.status.code).to.equal(202);
            const message2 = yield TestDataGenerator.generateRecordsWrite({
                author: bob,
                recipient: alice.did,
                parentContextId: thread.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/chat',
                protocolRole: 'thread/participant',
            });
            const message2Reply = yield dwn.processMessage(alice.did, message2.message, { dataStream: message2.dataStream });
            expect(message2Reply.status.code).to.equal(202);
            const message3 = yield TestDataGenerator.generateRecordsWrite({
                author: carol,
                recipient: alice.did,
                parentContextId: thread.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/chat',
                protocolRole: 'thread/participant',
            });
            const message3Reply = yield dwn.processMessage(alice.did, message3.message, { dataStream: message3.dataStream });
            expect(message3Reply.status.code).to.equal(202);
            // query for thread
            const threadQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ protocol: protocol, protocolPath: 'thread' }],
            });
            const threadQueryReply = yield dwn.processMessage(alice.did, threadQuery.message);
            expect(threadQueryReply.status.code).to.equal(200);
            expect((_x = threadQueryReply.entries) === null || _x === void 0 ? void 0 : _x.length).to.equal(1);
            expect(threadQueryReply.entries[0]).to.equal(yield Message.getCid(thread.message));
            // query for participants
            let participantsQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ protocol: protocol, protocolPath: 'thread/participant', parentId: thread.message.recordId }],
            });
            let participantsQueryReply = yield dwn.processMessage(alice.did, participantsQuery.message);
            expect(participantsQueryReply.status.code).to.equal(200);
            expect((_y = participantsQueryReply.entries) === null || _y === void 0 ? void 0 : _y.length).to.equal(2);
            expect(participantsQueryReply.entries[0]).to.equal(yield Message.getCid(bobParticipant.message));
            expect(participantsQueryReply.entries[1]).to.equal(yield Message.getCid(carolParticipant.message));
            // query for chats
            let chatQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ protocol: protocol, protocolPath: 'thread/chat', parentId: thread.message.recordId }],
            });
            let chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
            expect(chatQueryReply.status.code).to.equal(200);
            expect((_z = chatQueryReply.entries) === null || _z === void 0 ? void 0 : _z.length).to.equal(3);
            expect(chatQueryReply.entries[0]).to.equal(yield Message.getCid(message1.message));
            expect(chatQueryReply.entries[1]).to.equal(yield Message.getCid(message2.message));
            expect(chatQueryReply.entries[2]).to.equal(yield Message.getCid(message3.message));
            // delete carol participant
            const deleteCarol = yield TestDataGenerator.generateRecordsDelete({
                author: alice,
                recordId: carolParticipant.message.recordId
            });
            const deleteCarolReply = yield dwn.processMessage(alice.did, deleteCarol.message);
            expect(deleteCarolReply.status.code).to.equal(202);
            // query for participants past the cursor
            participantsQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ protocol: protocol, protocolPath: 'thread/participant', parentId: thread.message.recordId }],
                cursor: participantsQueryReply.cursor
            });
            participantsQueryReply = yield dwn.processMessage(alice.did, participantsQuery.message);
            expect(participantsQueryReply.status.code).to.equal(200);
            expect((_0 = participantsQueryReply.entries) === null || _0 === void 0 ? void 0 : _0.length).to.equal(1);
            expect(participantsQueryReply.entries[0]).to.equal(yield Message.getCid(deleteCarol.message));
            // query for chats beyond the cursor as a control, should have none.
            chatQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ protocol: protocol, protocolPath: 'thread/chat', parentId: thread.message.recordId }],
                cursor: chatQueryReply.cursor
            });
            chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
            expect(chatQueryReply.status.code).to.equal(200);
            expect((_1 = chatQueryReply.entries) === null || _1 === void 0 ? void 0 : _1.length).to.equal(0);
        }));
        it('filters by recipient', () => __awaiter(this, void 0, void 0, function* () {
            // scenario: alice installs a free-for-all protocol and makes posts with both bob and carol as recipients
            // carol and bob also make posts with alice as a recipient
            // alice queries for events meant for specific recipients
            // alice then makes another message to query for using the pervious as a cursor
            var _2, _3, _4;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const bob = yield TestDataGenerator.generateDidKeyPersona();
            const carol = yield TestDataGenerator.generateDidKeyPersona();
            const protocolConfigure = yield TestDataGenerator.generateProtocolsConfigure({
                author: alice,
                protocolDefinition: Object.assign({}, freeForAll)
            });
            const protocolConfigureReply = yield dwn.processMessage(alice.did, protocolConfigure.message);
            expect(protocolConfigureReply.status.code).to.equal(202);
            const protocol = protocolConfigure.message.descriptor.definition.protocol;
            const postProperties = {
                protocol: protocol,
                protocolPath: 'post',
                schema: freeForAll.types.post.schema,
                dataFormat: freeForAll.types.post.dataFormats[0],
            };
            const messageFromAliceToBob = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: alice, recipient: bob.did }));
            const messageFromAliceToBobReply = yield dwn.processMessage(alice.did, messageFromAliceToBob.message, { dataStream: messageFromAliceToBob.dataStream });
            expect(messageFromAliceToBobReply.status.code).to.equal(202);
            const messageFromAliceToCarol = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: alice, recipient: carol.did }));
            const messageFromAliceToCarolReply = yield dwn.processMessage(alice.did, messageFromAliceToCarol.message, { dataStream: messageFromAliceToCarol.dataStream });
            expect(messageFromAliceToCarolReply.status.code).to.equal(202);
            const messageFromBobToAlice = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: bob, recipient: alice.did }));
            const messageFromBobToAliceReply = yield dwn.processMessage(alice.did, messageFromBobToAlice.message, { dataStream: messageFromBobToAlice.dataStream });
            expect(messageFromBobToAliceReply.status.code).to.equal(202);
            const messageFromCarolToAlice = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: carol, recipient: alice.did }));
            const messageFromCarolToAliceReply = yield dwn.processMessage(alice.did, messageFromCarolToAlice.message, { dataStream: messageFromCarolToAlice.dataStream });
            expect(messageFromCarolToAliceReply.status.code).to.equal(202);
            let authorQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ recipient: alice.did }]
            });
            let authorQueryReply = yield dwn.processMessage(alice.did, authorQuery.message);
            expect(authorQueryReply.status.code).to.equal(200);
            expect((_2 = authorQueryReply.entries) === null || _2 === void 0 ? void 0 : _2.length).to.equal(2);
            expect(authorQueryReply.entries[0]).to.equal(yield Message.getCid(messageFromBobToAlice.message));
            expect(authorQueryReply.entries[1]).to.equal(yield Message.getCid(messageFromCarolToAlice.message));
            authorQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ recipient: bob.did }]
            });
            authorQueryReply = yield dwn.processMessage(alice.did, authorQuery.message);
            expect(authorQueryReply.status.code).to.equal(200);
            expect((_3 = authorQueryReply.entries) === null || _3 === void 0 ? void 0 : _3.length).to.equal(1);
            expect(authorQueryReply.entries[0]).to.equal(yield Message.getCid(messageFromAliceToBob.message));
            // add another message
            const messageFromAliceToBob2 = yield TestDataGenerator.generateRecordsWrite(Object.assign(Object.assign({}, postProperties), { author: alice, recipient: bob.did }));
            const messageFromAliceToBob2Reply = yield dwn.processMessage(alice.did, messageFromAliceToBob2.message, { dataStream: messageFromAliceToBob2.dataStream });
            expect(messageFromAliceToBob2Reply.status.code).to.equal(202);
            authorQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ recipient: bob.did }],
                cursor: authorQueryReply.cursor,
            });
            authorQueryReply = yield dwn.processMessage(alice.did, authorQuery.message);
            expect(authorQueryReply.status.code).to.equal(200);
            expect((_4 = authorQueryReply.entries) === null || _4 === void 0 ? void 0 : _4.length).to.equal(1);
            expect(authorQueryReply.entries[0]).to.equal(yield Message.getCid(messageFromAliceToBob2.message));
        }));
        it('filters by schema', () => __awaiter(this, void 0, void 0, function* () {
            var _5, _6, _7, _8;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const schema1Message1 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                schema: 'schema1'
            });
            const schema1Message1Reply = yield dwn.processMessage(alice.did, schema1Message1.message, { dataStream: schema1Message1.dataStream });
            expect(schema1Message1Reply.status.code).to.equal(202);
            const schema2Message1 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                schema: 'schema2'
            });
            const schema2Message1Reply = yield dwn.processMessage(alice.did, schema2Message1.message, { dataStream: schema2Message1.dataStream });
            expect(schema2Message1Reply.status.code).to.equal(202);
            const schema2Message2 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                schema: 'schema2'
            });
            const schema2Message2Reply = yield dwn.processMessage(alice.did, schema2Message2.message, { dataStream: schema2Message2.dataStream });
            expect(schema2Message2Reply.status.code).to.equal(202);
            let schema1Query = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ schema: 'schema1' }],
            });
            let schema1QueryReply = yield dwn.processMessage(alice.did, schema1Query.message);
            expect(schema1QueryReply.status.code).to.equal(200);
            expect((_5 = schema1QueryReply.entries) === null || _5 === void 0 ? void 0 : _5.length).to.equal(1);
            expect(schema1QueryReply.entries[0]).to.equal(yield Message.getCid(schema1Message1.message));
            let schema2Query = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ schema: 'schema2' }],
            });
            let schema2QueryReply = yield dwn.processMessage(alice.did, schema2Query.message);
            expect(schema2QueryReply.status.code).to.equal(200);
            expect((_6 = schema2QueryReply.entries) === null || _6 === void 0 ? void 0 : _6.length).to.equal(2);
            expect(schema2QueryReply.entries[0]).to.equal(yield Message.getCid(schema2Message1.message));
            expect(schema2QueryReply.entries[1]).to.equal(yield Message.getCid(schema2Message2.message));
            const schema1Message2 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                schema: 'schema1'
            });
            const schema1Message2Reply = yield dwn.processMessage(alice.did, schema1Message2.message, { dataStream: schema1Message2.dataStream });
            expect(schema1Message2Reply.status.code).to.equal(202);
            schema1Query = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ schema: 'schema1' }],
                cursor: schema1QueryReply.cursor,
            });
            schema1QueryReply = yield dwn.processMessage(alice.did, schema1Query.message);
            expect(schema1QueryReply.status.code).to.equal(200);
            expect((_7 = schema1QueryReply.entries) === null || _7 === void 0 ? void 0 : _7.length).to.equal(1);
            expect(schema1QueryReply.entries[0]).to.equal(yield Message.getCid(schema1Message2.message));
            schema2Query = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ schema: 'schema2' }],
                cursor: schema2QueryReply.cursor,
            });
            schema2QueryReply = yield dwn.processMessage(alice.did, schema2Query.message);
            expect(schema2QueryReply.status.code).to.equal(200);
            expect((_8 = schema2QueryReply.entries) === null || _8 === void 0 ? void 0 : _8.length).to.equal(0);
        }));
        it('filters by recordId', () => __awaiter(this, void 0, void 0, function* () {
            var _9, _10;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            // a write as a control, will not show up in query
            const controlWrite = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                schema: 'schema1'
            });
            const write2Reply = yield dwn.processMessage(alice.did, controlWrite.message, { dataStream: controlWrite.dataStream });
            expect(write2Reply.status.code).to.equal(202);
            const write = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                schema: 'schema1'
            });
            const write1Reply = yield dwn.processMessage(alice.did, write.message, { dataStream: write.dataStream });
            expect(write1Reply.status.code).to.equal(202);
            const update = yield TestDataGenerator.generateFromRecordsWrite({
                author: alice,
                existingWrite: write.recordsWrite,
            });
            const updateReply = yield dwn.processMessage(alice.did, update.message, { dataStream: update.dataStream });
            expect(updateReply.status.code).to.equal(202);
            let recordQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ recordId: write.message.recordId }],
            });
            let recordQueryReply = yield dwn.processMessage(alice.did, recordQuery.message);
            expect(recordQueryReply.status.code).to.equal(200);
            expect((_9 = recordQueryReply.entries) === null || _9 === void 0 ? void 0 : _9.length).to.equal(2);
            expect(recordQueryReply.entries[0]).to.equal(yield Message.getCid(write.message));
            expect(recordQueryReply.entries[1]).to.equal(yield Message.getCid(update.message));
            const deleteRecord = yield TestDataGenerator.generateRecordsDelete({
                author: alice,
                recordId: write.message.recordId,
            });
            const deleteRecordReply = yield dwn.processMessage(alice.did, deleteRecord.message);
            expect(deleteRecordReply.status.code).to.equal(202);
            recordQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{ recordId: write.message.recordId }],
                cursor: recordQueryReply.cursor,
            });
            recordQueryReply = yield dwn.processMessage(alice.did, recordQuery.message);
            expect(recordQueryReply.status.code).to.equal(200);
            expect((_10 = recordQueryReply.entries) === null || _10 === void 0 ? void 0 : _10.length).to.equal(1);
            expect(recordQueryReply.entries[0]).to.equal(yield Message.getCid(deleteRecord.message));
        }));
        it('filters by dataFormat', () => __awaiter(this, void 0, void 0, function* () {
            // scenario: alice stores different file types and needs events relating to `image/jpeg`
            //  alice creates 3 files, one of them `image/jpeg`
            //  alice queries for `image/jpeg` retrieving the one message
            //  alice adds another image to query for using the prior image as a cursor
            var _11, _12;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const textFile = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                dataFormat: 'application/text'
            });
            const textFileReply = yield dwn.processMessage(alice.did, textFile.message, { dataStream: textFile.dataStream });
            expect(textFileReply.status.code).to.equal(202);
            const jsonData = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                dataFormat: 'application/json'
            });
            const jsonDataReply = yield dwn.processMessage(alice.did, jsonData.message, { dataStream: jsonData.dataStream });
            expect(jsonDataReply.status.code).to.equal(202);
            const imageData = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                dataFormat: 'image/jpeg'
            });
            const imageDataReply = yield dwn.processMessage(alice.did, imageData.message, { dataStream: imageData.dataStream });
            expect(imageDataReply.status.code).to.equal(202);
            //get image data
            let imageQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{
                        dataFormat: 'image/jpeg'
                    }]
            });
            let imageQueryReply = yield dwn.processMessage(alice.did, imageQuery.message);
            expect(imageQueryReply.status.code).to.equal(200);
            expect((_11 = imageQueryReply.entries) === null || _11 === void 0 ? void 0 : _11.length).to.equal(1);
            expect(imageQueryReply.entries[0]).to.equal(yield Message.getCid(imageData.message));
            // add another image
            const imageData2 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                dataFormat: 'image/jpeg'
            });
            const imageData2Reply = yield dwn.processMessage(alice.did, imageData2.message, { dataStream: imageData2.dataStream });
            expect(imageData2Reply.status.code).to.equal(202);
            imageQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{
                        dataFormat: 'image/jpeg'
                    }],
                cursor: imageQueryReply.cursor,
            });
            imageQueryReply = yield dwn.processMessage(alice.did, imageQuery.message);
            expect(imageQueryReply.status.code).to.equal(200);
            expect((_12 = imageQueryReply.entries) === null || _12 === void 0 ? void 0 : _12.length).to.equal(1);
            expect(imageQueryReply.entries[0]).to.equal(yield Message.getCid(imageData2.message));
        }));
        ;
        it('filters by dataSize', () => __awaiter(this, void 0, void 0, function* () {
            // scenario:
            //    alice inserts both small and large data
            //    alice requests events for messages with data size under a threshold
            var _13, _14;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const smallSize1 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
            });
            const smallSize1Reply = yield dwn.processMessage(alice.did, smallSize1.message, { dataStream: smallSize1.dataStream });
            expect(smallSize1Reply.status.code).to.equal(202);
            const largeSize = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                data: TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded + 1)
            });
            const largeSizeReply = yield dwn.processMessage(alice.did, largeSize.message, { dataStream: largeSize.dataStream });
            expect(largeSizeReply.status.code).to.equal(202);
            const smallSize2 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
            });
            const smallSize2Reply = yield dwn.processMessage(alice.did, smallSize2.message, { dataStream: smallSize2.dataStream });
            expect(smallSize2Reply.status.code).to.equal(202);
            //get large sizes
            let largeSizeQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{
                        dataSize: { gte: DwnConstant.maxDataSizeAllowedToBeEncoded + 1 }
                    }]
            });
            let largeSizeQueryReply = yield dwn.processMessage(alice.did, largeSizeQuery.message);
            expect(largeSizeQueryReply.status.code).to.equal(200);
            expect((_13 = largeSizeQueryReply.entries) === null || _13 === void 0 ? void 0 : _13.length).to.equal(1);
            expect(largeSizeQueryReply.entries[0]).to.equal(yield Message.getCid(largeSize.message));
            const largeSize2 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                data: TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded + 1)
            });
            const largeSize2Reply = yield dwn.processMessage(alice.did, largeSize2.message, { dataStream: largeSize2.dataStream });
            expect(largeSize2Reply.status.code).to.equal(202);
            largeSizeQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{
                        dataSize: { gte: DwnConstant.maxDataSizeAllowedToBeEncoded + 1 }
                    }],
                cursor: largeSizeQueryReply.cursor,
            });
            largeSizeQueryReply = yield dwn.processMessage(alice.did, largeSizeQuery.message);
            expect(largeSizeQueryReply.status.code).to.equal(200);
            expect((_14 = largeSizeQueryReply.entries) === null || _14 === void 0 ? void 0 : _14.length).to.equal(1);
            expect(largeSizeQueryReply.entries[0]).to.equal(yield Message.getCid(largeSize2.message));
        }));
        it('filters by contextId', () => __awaiter(this, void 0, void 0, function* () {
            // scenario:
            //    alice configures a chat protocols and creates 2 chat threads
            //    alice invites bob as participant in thread1 and carol in thread2
            //    alice writes messages to both bob and carol in their respective threads
            //    alice queries for events related to thread1 (gets the configure, bob participant, and chats to bob)
            //    alice writes more messages to both bob and carol in their respective threads
            //    alice queries for events beyond the latest from the last query, retrieving the additional messages to bob
            var _15, _16;
            const alice = yield TestDataGenerator.generateDidKeyPersona();
            const bob = yield TestDataGenerator.generateDidKeyPersona();
            const carol = yield TestDataGenerator.generateDidKeyPersona();
            const protocolConfigure = yield TestDataGenerator.generateProtocolsConfigure({
                author: alice,
                protocolDefinition: Object.assign({}, threadProtocol)
            });
            const protocolConfigureReply = yield dwn.processMessage(alice.did, protocolConfigure.message);
            expect(protocolConfigureReply.status.code).to.equal(202);
            const protocol = protocolConfigure.message.descriptor.definition.protocol;
            // alice creates 2 threads
            const thread1 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                protocol: protocol,
                protocolPath: 'thread',
            });
            const thread1Reply = yield dwn.processMessage(alice.did, thread1.message, { dataStream: thread1.dataStream });
            expect(thread1Reply.status.code).to.equal(202);
            const thread2 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                protocol: protocol,
                protocolPath: 'thread',
            });
            const thread2Reply = yield dwn.processMessage(alice.did, thread2.message, { dataStream: thread2.dataStream });
            expect(thread2Reply.status.code).to.equal(202);
            // alice adds bob as a participant to thread 1
            const bobParticipant = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                recipient: bob.did,
                parentContextId: thread1.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/participant'
            });
            const bobParticipantReply = yield dwn.processMessage(alice.did, bobParticipant.message, { dataStream: bobParticipant.dataStream });
            expect(bobParticipantReply.status.code).to.equal(202);
            // alice adds carol as a participant to thread 1
            const carolParticipant = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                recipient: carol.did,
                parentContextId: thread2.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/participant'
            });
            const carolParticipantReply = yield dwn.processMessage(alice.did, carolParticipant.message, { dataStream: carolParticipant.dataStream });
            expect(carolParticipantReply.status.code).to.equal(202);
            // alice writes a message to bob on thread 1
            const thread1Chat1 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                recipient: bob.did,
                parentContextId: thread1.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/chat',
            });
            const thread1Chat1Reply = yield dwn.processMessage(alice.did, thread1Chat1.message, { dataStream: thread1Chat1.dataStream });
            expect(thread1Chat1Reply.status.code).to.equal(202);
            // alice writes a message to carol on thread 2
            const thread2Chat1 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                recipient: carol.did,
                parentContextId: thread2.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/chat',
            });
            const thread2Chat1Reply = yield dwn.processMessage(alice.did, thread2Chat1.message, { dataStream: thread2Chat1.dataStream });
            expect(thread2Chat1Reply.status.code).to.equal(202);
            // alice writes another message to bob on thread 1
            const thread1Chat2 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                recipient: bob.did,
                parentContextId: thread1.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/chat',
            });
            const chatMessage2Reply = yield dwn.processMessage(alice.did, thread1Chat2.message, { dataStream: thread1Chat2.dataStream });
            expect(chatMessage2Reply.status.code).to.equal(202);
            // alice queries events for thread1
            let threadContextQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{
                        protocol: protocol,
                        contextId: thread1.message.contextId,
                    }],
            });
            let threadContextQueryReply = yield dwn.processMessage(alice.did, threadContextQuery.message);
            expect(threadContextQueryReply.status.code).to.equal(200);
            expect((_15 = threadContextQueryReply.entries) === null || _15 === void 0 ? void 0 : _15.length).to.equal(4);
            expect(threadContextQueryReply.entries[0]).to.equal(yield Message.getCid(thread1.message));
            expect(threadContextQueryReply.entries[1]).to.equal(yield Message.getCid(bobParticipant.message));
            expect(threadContextQueryReply.entries[2]).to.equal(yield Message.getCid(thread1Chat1.message));
            expect(threadContextQueryReply.entries[3]).to.equal(yield Message.getCid(thread1Chat2.message));
            // alice adds more chats to both threads
            const thread1Chat3 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                recipient: bob.did,
                parentContextId: thread1.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/chat',
            });
            const thread1Chat3Reply = yield dwn.processMessage(alice.did, thread1Chat3.message, { dataStream: thread1Chat3.dataStream });
            expect(thread1Chat3Reply.status.code).to.equal(202);
            const thread2Chat2 = yield TestDataGenerator.generateRecordsWrite({
                author: alice,
                recipient: carol.did,
                parentContextId: thread2.message.contextId,
                protocol: protocol,
                protocolPath: 'thread/chat',
            });
            const thread2Chat2Reply = yield dwn.processMessage(alice.did, thread2Chat2.message, { dataStream: thread2Chat2.dataStream });
            expect(thread2Chat2Reply.status.code).to.equal(202);
            // query beyond a cursor
            threadContextQuery = yield TestDataGenerator.generateEventsQuery({
                author: alice,
                filters: [{
                        protocol: protocol,
                        contextId: thread1.message.contextId,
                    }],
                cursor: threadContextQueryReply.cursor,
            });
            threadContextQueryReply = yield dwn.processMessage(alice.did, threadContextQuery.message);
            expect(threadContextQueryReply.status.code).to.equal(200);
            expect((_16 = threadContextQueryReply.entries) === null || _16 === void 0 ? void 0 : _16.length).to.equal(1);
            expect(threadContextQueryReply.entries[0]).to.equal(yield Message.getCid(thread1Chat3.message));
        }));
    });
}
;
//# sourceMappingURL=events-query.spec.js.map