var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Dwn } from '../../src/dwn.js';
import { DwnErrorCode } from '../../src/core/dwn-error.js';
import { EventsSubscribe } from '../../src/interfaces/events-subscribe.js';
import { Jws } from '../../src/utils/jws.js';
import { Message } from '../../src/core/message.js';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestEventStream } from '../test-event-stream.js';
import { TestStores } from '../test-stores.js';
import { DidKey, UniversalResolver } from '@web5/dids';
import sinon from 'sinon';
import chai, { expect } from 'chai';
import chaiAsPromised from 'chai-as-promised';
import { EventsSubscribeHandler } from '../../src/handlers/events-subscribe.js';
chai.use(chaiAsPromised);
export function testEventsSubscribeHandler() {
    describe('EventsSubscribe.handle()', () => {
        describe('EventStream disabled', () => {
            let didResolver;
            let messageStore;
            let dataStore;
            let eventLog;
            let dwn;
            // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
            // so that different test suites can reuse the same backend store for testing
            before(() => __awaiter(this, void 0, void 0, function* () {
                didResolver = new UniversalResolver({ didResolvers: [DidKey] });
                const stores = TestStores.get();
                messageStore = stores.messageStore;
                dataStore = stores.dataStore;
                eventLog = stores.eventLog;
                dwn = yield Dwn.create({
                    didResolver,
                    messageStore,
                    dataStore,
                    eventLog,
                });
            }));
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
                // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
                yield messageStore.clear();
                yield dataStore.clear();
                yield eventLog.clear();
            }));
            after(() => __awaiter(this, void 0, void 0, function* () {
                yield dwn.close();
            }));
            it('should respond with a 501 if subscriptions are not supported', () => __awaiter(this, void 0, void 0, function* () {
                yield dwn.close(); // close the original dwn instance
                dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog }); // leave out eventStream
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // attempt to subscribe
                const { message } = yield EventsSubscribe.create({ signer: Jws.createSigner(alice) });
                const subscriptionMessageReply = yield dwn.processMessage(alice.did, message, { subscriptionHandler: (_) => { } });
                expect(subscriptionMessageReply.status.code).to.equal(501, subscriptionMessageReply.status.detail);
                expect(subscriptionMessageReply.status.detail).to.include(DwnErrorCode.EventsSubscribeEventStreamUnimplemented);
            }));
        });
        describe('EventStream enabled', () => {
            let didResolver;
            let messageStore;
            let dataStore;
            let eventLog;
            let eventStream;
            let dwn;
            // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
            // so that different test suites can reuse the same backend store for testing
            before(() => __awaiter(this, void 0, void 0, function* () {
                didResolver = new UniversalResolver({ didResolvers: [DidKey] });
                const stores = TestStores.get();
                messageStore = stores.messageStore;
                dataStore = stores.dataStore;
                eventLog = stores.eventLog;
                eventStream = TestEventStream.get();
                dwn = yield Dwn.create({
                    didResolver,
                    messageStore,
                    dataStore,
                    eventLog,
                    eventStream,
                });
            }));
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
                // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
                yield messageStore.clear();
                yield dataStore.clear();
                yield eventLog.clear();
            }));
            after(() => __awaiter(this, void 0, void 0, function* () {
                yield dwn.close();
            }));
            it('returns a 400 if message is invalid', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const { message } = yield TestDataGenerator.generateEventsSubscribe({ author: alice });
                // add an invalid property to the descriptor
                message['descriptor']['invalid'] = 'invalid';
                const eventsSubscribeHandler = new EventsSubscribeHandler(didResolver, eventStream);
                const reply = yield eventsSubscribeHandler.handle({ tenant: alice.did, message, subscriptionHandler: (_) => { } });
                expect(reply.status.code).to.equal(400);
            }));
            it('should allow tenant to subscribe their own event stream', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                // set up a promise to read later that captures the emitted messageCid
                let handler;
                const messageSubscriptionPromise = new Promise((resolve) => {
                    handler = (event) => __awaiter(this, void 0, void 0, function* () {
                        const { message } = event;
                        const messageCid = yield Message.getCid(message);
                        resolve(messageCid);
                    });
                });
                // testing EventsSubscribe
                const eventsSubscribe = yield EventsSubscribe.create({
                    signer: Jws.createSigner(alice),
                });
                const subscriptionReply = yield dwn.processMessage(alice.did, eventsSubscribe.message, { subscriptionHandler: handler });
                expect(subscriptionReply.status.code).to.equal(200, subscriptionReply.status.detail);
                expect(subscriptionReply.subscription).to.not.be.undefined;
                const messageWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const writeReply = yield dwn.processMessage(alice.did, messageWrite.message, { dataStream: messageWrite.dataStream });
                expect(writeReply.status.code).to.equal(202);
                const messageCid = yield Message.getCid(messageWrite.message);
                // control: ensure that the event exists
                const { events } = yield eventLog.getEvents(alice.did);
                expect(events.length).to.equal(1);
                expect(events[0]).to.equal(messageCid);
                // await the event
                yield expect(messageSubscriptionPromise).to.eventually.equal(messageCid);
            }));
            it('should not allow non-tenant to subscribe to an event stream they are not authorized for', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield TestDataGenerator.generateDidKeyPersona();
                const bob = yield TestDataGenerator.generateDidKeyPersona();
                // test anonymous request
                const anonymousSubscription = yield TestDataGenerator.generateEventsSubscribe();
                delete anonymousSubscription.message.authorization;
                const anonymousReply = yield dwn.processMessage(alice.did, anonymousSubscription.message);
                expect(anonymousReply.status.code).to.equal(400);
                expect(anonymousReply.status.detail).to.include(`EventsSubscribe: must have required property 'authorization'`);
                expect(anonymousReply.subscription).to.be.undefined;
                // testing EventsSubscribe
                const eventsSubscribe = yield EventsSubscribe.create({
                    signer: Jws.createSigner(bob),
                });
                const subscriptionReply = yield dwn.processMessage(alice.did, eventsSubscribe.message);
                expect(subscriptionReply.status.code).to.equal(401);
                expect(subscriptionReply.subscription).to.be.undefined;
            }));
        });
    });
}
//# sourceMappingURL=events-subscribe.spec.js.map