var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { TestEventStream } from '../test-event-stream.js';
import { Message, TestDataGenerator, Time } from '../../src/index.js';
import chaiAsPromised from 'chai-as-promised';
import chai, { expect } from 'chai';
chai.use(chaiAsPromised);
describe('EventStream', () => {
    // saving the original `console.error` function to re-assign after tests complete
    const originalConsoleErrorFunction = console.error;
    let eventStream;
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        eventStream = TestEventStream.get();
        yield eventStream.open();
        // do not print the console error statements from the emitter error
        console.error = (_) => { };
    }));
    after(() => __awaiter(void 0, void 0, void 0, function* () {
        console.error = originalConsoleErrorFunction;
        // Clean up after each test by closing and clearing the event stream
        yield eventStream.close();
    }));
    it('emits all messages to each subscriptions', () => __awaiter(void 0, void 0, void 0, function* () {
        const messageCids1 = [];
        const handler1 = (_tenant, event, _indexes) => __awaiter(void 0, void 0, void 0, function* () {
            const { message } = event;
            const messageCid = yield Message.getCid(message);
            messageCids1.push(messageCid);
        });
        const messageCids2 = [];
        const handler2 = (_tenant, event, _indexes) => __awaiter(void 0, void 0, void 0, function* () {
            const { message } = event;
            const messageCid = yield Message.getCid(message);
            messageCids2.push(messageCid);
        });
        const subscription1 = yield eventStream.subscribe('did:alice', 'sub-1', handler1);
        const subscription2 = yield eventStream.subscribe('did:alice', 'sub-2', handler2);
        const message1 = yield TestDataGenerator.generateRecordsWrite({});
        const message1Cid = yield Message.getCid(message1.message);
        eventStream.emit('did:alice', { message: message1.message }, {});
        const message2 = yield TestDataGenerator.generateRecordsWrite({});
        const message2Cid = yield Message.getCid(message2.message);
        eventStream.emit('did:alice', { message: message2.message }, {});
        const message3 = yield TestDataGenerator.generateRecordsWrite({});
        const message3Cid = yield Message.getCid(message3.message);
        eventStream.emit('did:alice', { message: message3.message }, {});
        yield subscription1.close();
        yield subscription2.close();
        yield Time.minimalSleep();
        expect(messageCids1).to.have.members([message1Cid, message2Cid, message3Cid]);
        expect(messageCids2).to.have.members([message1Cid, message2Cid, message3Cid]);
    }));
    it('does not emit messages if subscription is closed', () => __awaiter(void 0, void 0, void 0, function* () {
        const messageCids = [];
        const handler = (_tenant, event, _indexes) => __awaiter(void 0, void 0, void 0, function* () {
            const { message } = event;
            const messageCid = yield Message.getCid(message);
            messageCids.push(messageCid);
        });
        const subscription = yield eventStream.subscribe('did:alice', 'sub-1', handler);
        const message1 = yield TestDataGenerator.generateRecordsWrite({});
        const message1Cid = yield Message.getCid(message1.message);
        eventStream.emit('did:alice', { message: message1.message }, {});
        yield subscription.close();
        const message2 = yield TestDataGenerator.generateRecordsWrite({});
        eventStream.emit('did:alice', { message: message2.message }, {});
        yield Time.minimalSleep();
        expect(messageCids).to.have.members([message1Cid]);
    }));
    it('does not emit messages if event stream is closed', () => __awaiter(void 0, void 0, void 0, function* () {
        const messageCids = [];
        const handler = (_tenant, event, _indexes) => __awaiter(void 0, void 0, void 0, function* () {
            const { message } = event;
            const messageCid = yield Message.getCid(message);
            messageCids.push(messageCid);
        });
        const subscription = yield eventStream.subscribe('did:alice', 'sub-1', handler);
        // close eventStream
        yield eventStream.close();
        const message1 = yield TestDataGenerator.generateRecordsWrite({});
        eventStream.emit('did:alice', { message: message1.message }, {});
        const message2 = yield TestDataGenerator.generateRecordsWrite({});
        eventStream.emit('did:alice', { message: message2.message }, {});
        yield subscription.close();
        yield Time.minimalSleep();
        expect(messageCids).to.have.length(0);
    }));
});
//# sourceMappingURL=event-stream.spec.js.map