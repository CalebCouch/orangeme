// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'pub_structs.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`

Future<void> loadStructs(
        {required ShorthandTransaction s,
        required ShorthandConversation sc,
        required Conversation c,
        required Message m,
        required Profile p,
        required DartMethod dm,
        required KeyPress kp}) =>
    RustLib.instance.api.crateApiPubStructsLoadStructs(
        s: s, sc: sc, c: c, m: m, p: p, dm: dm, kp: kp);

Future<void> loadStructs2({required Platform pl, required PageName pn}) =>
    RustLib.instance.api.crateApiPubStructsLoadStructs2(pl: pl, pn: pn);

class Conversation {
  final List<Profile> members;
  final List<Message> messages;
  final String roomId;

  const Conversation({
    required this.members,
    required this.messages,
    required this.roomId,
  });

  @override
  int get hashCode => members.hashCode ^ messages.hashCode ^ roomId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Conversation &&
          runtimeType == other.runtimeType &&
          members == other.members &&
          messages == other.messages &&
          roomId == other.roomId;
}

@freezed
sealed class DartMethod with _$DartMethod {
  const DartMethod._();

  const factory DartMethod.storageSet(
    String field0,
    String field1,
  ) = DartMethod_StorageSet;
  const factory DartMethod.storageGet(
    String field0,
  ) = DartMethod_StorageGet;
}

enum KeyPress {
  zero,
  one,
  two,
  three,
  four,
  five,
  six,
  seven,
  eight,
  nine,
  reset,
  decimal,
  backspace,
  ;
}

class Message {
  final Profile sender;
  final String message;
  final String date;
  final String time;

  const Message({
    required this.sender,
    required this.message,
    required this.date,
    required this.time,
  });

  @override
  int get hashCode =>
      sender.hashCode ^ message.hashCode ^ date.hashCode ^ time.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Message &&
          runtimeType == other.runtimeType &&
          sender == other.sender &&
          message == other.message &&
          date == other.date &&
          time == other.time;
}

@freezed
sealed class PageName with _$PageName {
  const PageName._();

  const factory PageName.bitcoinHome() = PageName_BitcoinHome;
  const factory PageName.viewTransaction(
    String field0,
  ) = PageName_ViewTransaction;
  const factory PageName.receive() = PageName_Receive;
  const factory PageName.send(
    String field0,
  ) = PageName_Send;
  const factory PageName.amount(
    String field0,
  ) = PageName_Amount;
  const factory PageName.speed(
    BigInt field0,
  ) = PageName_Speed;
  const factory PageName.confirm(
    String field0,
    BigInt field1,
    BigInt field2,
  ) = PageName_Confirm;
  const factory PageName.success(
    String field0,
  ) = PageName_Success;
  const factory PageName.myProfile(
    bool field0,
  ) = PageName_MyProfile;
  const factory PageName.userProfile(
    bool field0,
  ) = PageName_UserProfile;
  const factory PageName.messagesHome() = PageName_MessagesHome;
  const factory PageName.chooseRecipient() = PageName_ChooseRecipient;
  const factory PageName.conversation() = PageName_Conversation;
  const factory PageName.conversationInfo() = PageName_ConversationInfo;
  const factory PageName.test(
    String field0,
  ) = PageName_Test;
}

enum Platform {
  mac,
  linux,
  windows,
  ios,
  android,
  fuchsia,
  ;

  bool isDesktop() => RustLib.instance.api.crateApiPubStructsPlatformIsDesktop(
        that: this,
      );
}

class Profile {
  final String name;
  final String did;
  final String? pfpPath;
  final String? abtMe;

  const Profile({
    required this.name,
    required this.did,
    this.pfpPath,
    this.abtMe,
  });

  @override
  int get hashCode =>
      name.hashCode ^ did.hashCode ^ pfpPath.hashCode ^ abtMe.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Profile &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          did == other.did &&
          pfpPath == other.pfpPath &&
          abtMe == other.abtMe;
}

class ShorthandConversation {
  final String roomName;
  final String? photo;
  final String subtext;
  final bool isGroup;
  final String roomId;

  const ShorthandConversation({
    required this.roomName,
    this.photo,
    required this.subtext,
    required this.isGroup,
    required this.roomId,
  });

  @override
  int get hashCode =>
      roomName.hashCode ^
      photo.hashCode ^
      subtext.hashCode ^
      isGroup.hashCode ^
      roomId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ShorthandConversation &&
          runtimeType == other.runtimeType &&
          roomName == other.roomName &&
          photo == other.photo &&
          subtext == other.subtext &&
          isGroup == other.isGroup &&
          roomId == other.roomId;
}

class ShorthandTransaction {
  final bool isWithdraw;
  final String datetime;
  final String amount;
  final String txid;

  const ShorthandTransaction({
    required this.isWithdraw,
    required this.datetime,
    required this.amount,
    required this.txid,
  });

  @override
  int get hashCode =>
      isWithdraw.hashCode ^ datetime.hashCode ^ amount.hashCode ^ txid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ShorthandTransaction &&
          runtimeType == other.runtimeType &&
          isWithdraw == other.isWithdraw &&
          datetime == other.datetime &&
          amount == other.amount &&
          txid == other.txid;
}
