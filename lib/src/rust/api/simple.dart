// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.2.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `from_details`, `generate_legacy_descriptor`, `generate_seed`, `get_descriptors`, `get_os`, `get_price`, `invoke`
// These types are ignored because they are not used by any `pub` functions: `DartCommand`, `Data`, `DescriptorSet`, `PriceRes`, `Price`, `RustCommand`, `RustResponse`, `SeedSet`, `SpotRes`, `Spot`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

Future<String> rustStart(
        {required String path,
        required FutureOr<String> Function(String) callback,
        required FutureOr<String> Function(String) callback3,
        required FutureOr<String> Function(String) callback1}) =>
    RustLib.instance.api.crateApiSimpleRustStart(
        path: path,
        callback: callback,
        callback3: callback3,
        callback1: callback1);

class DartState {
  final double currentPrice;
  final double usdBalance;
  final double btcBalance;
  final List<Transaction> transactions;
  final Float64List fees;

  const DartState({
    required this.currentPrice,
    required this.usdBalance,
    required this.btcBalance,
    required this.transactions,
    required this.fees,
  });

  static Future<DartState> default_() =>
      RustLib.instance.api.crateApiSimpleDartStateDefault();

  @override
  int get hashCode =>
      currentPrice.hashCode ^
      usdBalance.hashCode ^
      btcBalance.hashCode ^
      transactions.hashCode ^
      fees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartState &&
          runtimeType == other.runtimeType &&
          currentPrice == other.currentPrice &&
          usdBalance == other.usdBalance &&
          btcBalance == other.btcBalance &&
          transactions == other.transactions &&
          fees == other.fees;
}

class Transaction {
  final bool isReceive;
  final String? sentAddress;
  final String txid;
  final double usd;
  final double btc;
  final double price;
  final double fee;
  final String? date;
  final String? time;

  const Transaction({
    required this.isReceive,
    this.sentAddress,
    required this.txid,
    required this.usd,
    required this.btc,
    required this.price,
    required this.fee,
    this.date,
    this.time,
  });

  @override
  int get hashCode =>
      isReceive.hashCode ^
      sentAddress.hashCode ^
      txid.hashCode ^
      usd.hashCode ^
      btc.hashCode ^
      price.hashCode ^
      fee.hashCode ^
      date.hashCode ^
      time.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Transaction &&
          runtimeType == other.runtimeType &&
          isReceive == other.isReceive &&
          sentAddress == other.sentAddress &&
          txid == other.txid &&
          usd == other.usd &&
          btc == other.btc &&
          price == other.price &&
          fee == other.fee &&
          date == other.date &&
          time == other.time;
}
