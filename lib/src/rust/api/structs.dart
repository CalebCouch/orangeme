// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_str`

class Contact {
  final String name;
  final String did;
  final String? pfp;
  final String? abtme;

  const Contact({
    required this.name,
    required this.did,
    this.pfp,
    this.abtme,
  });

  static Future<Contact> default_() =>
      RustLib.instance.api.crateApiStructsContactDefault();

  @override
  int get hashCode =>
      name.hashCode ^ did.hashCode ^ pfp.hashCode ^ abtme.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Contact &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          did == other.did &&
          pfp == other.pfp &&
          abtme == other.abtme;
}

class Conversation {
  final List<Message> messages;
  final List<Contact> members;

  const Conversation({
    required this.messages,
    required this.members,
  });

  static Future<Conversation> default_() =>
      RustLib.instance.api.crateApiStructsConversationDefault();

  @override
  int get hashCode => messages.hashCode ^ members.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Conversation &&
          runtimeType == other.runtimeType &&
          messages == other.messages &&
          members == other.members;
}

class DartCommand {
  final String method;
  final String data;

  const DartCommand({
    required this.method,
    required this.data,
  });

  static Future<DartCommand> default_() =>
      RustLib.instance.api.crateApiStructsDartCommandDefault();

  @override
  int get hashCode => method.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartCommand &&
          runtimeType == other.runtimeType &&
          method == other.method &&
          data == other.data;
}

class DartState {
  final double currentPrice;
  final double usdBalance;
  final double btcBalance;
  final List<Transaction> transactions;
  final Float64List fees;
  final List<Conversation> conversations;
  final List<Contact> users;
  final Contact personal;

  const DartState({
    required this.currentPrice,
    required this.usdBalance,
    required this.btcBalance,
    required this.transactions,
    required this.fees,
    required this.conversations,
    required this.users,
    required this.personal,
  });

  static Future<DartState> default_() =>
      RustLib.instance.api.crateApiStructsDartStateDefault();

  @override
  int get hashCode =>
      currentPrice.hashCode ^
      usdBalance.hashCode ^
      btcBalance.hashCode ^
      transactions.hashCode ^
      fees.hashCode ^
      conversations.hashCode ^
      users.hashCode ^
      personal.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartState &&
          runtimeType == other.runtimeType &&
          currentPrice == other.currentPrice &&
          usdBalance == other.usdBalance &&
          btcBalance == other.btcBalance &&
          transactions == other.transactions &&
          fees == other.fees &&
          conversations == other.conversations &&
          users == other.users &&
          personal == other.personal;
}

class Message {
  final Contact sender;
  final String message;
  final String date;
  final String time;
  final bool isIncoming;

  const Message({
    required this.sender,
    required this.message,
    required this.date,
    required this.time,
    required this.isIncoming,
  });

  static Future<Message> default_() =>
      RustLib.instance.api.crateApiStructsMessageDefault();

  @override
  int get hashCode =>
      sender.hashCode ^
      message.hashCode ^
      date.hashCode ^
      time.hashCode ^
      isIncoming.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Message &&
          runtimeType == other.runtimeType &&
          sender == other.sender &&
          message == other.message &&
          date == other.date &&
          time == other.time &&
          isIncoming == other.isIncoming;
}

enum Platform {
  mac,
  linux,
  windows,
  ios,
  android,
  fuchsia,
  ;

  Future<bool> isDesktop() =>
      RustLib.instance.api.crateApiStructsPlatformIsDesktop(
        that: this,
      );
}

class RustCommand {
  final String uid;
  final String method;
  final String data;

  const RustCommand({
    required this.uid,
    required this.method,
    required this.data,
  });

  static Future<RustCommand> default_() =>
      RustLib.instance.api.crateApiStructsRustCommandDefault();

  @override
  int get hashCode => uid.hashCode ^ method.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustCommand &&
          runtimeType == other.runtimeType &&
          uid == other.uid &&
          method == other.method &&
          data == other.data;
}

class RustResponse {
  final String uid;
  final String data;

  const RustResponse({
    required this.uid,
    required this.data,
  });

  static Future<RustResponse> default_() =>
      RustLib.instance.api.crateApiStructsRustResponseDefault();

  @override
  int get hashCode => uid.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustResponse &&
          runtimeType == other.runtimeType &&
          uid == other.uid &&
          data == other.data;
}

class Transaction {
  final bool isReceive;
  final String? sentAddress;
  final String txid;
  final double usd;
  final double btc;
  final double price;
  final double fee;
  final String? date;
  final String? time;

  const Transaction({
    required this.isReceive,
    this.sentAddress,
    required this.txid,
    required this.usd,
    required this.btc,
    required this.price,
    required this.fee,
    this.date,
    this.time,
  });

  static Future<Transaction> default_() =>
      RustLib.instance.api.crateApiStructsTransactionDefault();

  @override
  int get hashCode =>
      isReceive.hashCode ^
      sentAddress.hashCode ^
      txid.hashCode ^
      usd.hashCode ^
      btc.hashCode ^
      price.hashCode ^
      fee.hashCode ^
      date.hashCode ^
      time.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Transaction &&
          runtimeType == other.runtimeType &&
          isReceive == other.isReceive &&
          sentAddress == other.sentAddress &&
          txid == other.txid &&
          usd == other.usd &&
          btc == other.btc &&
          price == other.price &&
          fee == other.fee &&
          date == other.date &&
          time == other.time;
}
